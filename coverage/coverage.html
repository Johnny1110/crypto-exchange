
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>chainUtil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/johnny1110/crypto-exchange/chainUtil/chainUtils.go (0.0%)</option>
				
				<option value="file1">github.com/johnny1110/crypto-exchange/container/container.go (0.0%)</option>
				
				<option value="file2">github.com/johnny1110/crypto-exchange/controller/admins.go (0.0%)</option>
				
				<option value="file3">github.com/johnny1110/crypto-exchange/controller/balances.go (0.0%)</option>
				
				<option value="file4">github.com/johnny1110/crypto-exchange/controller/markets.go (0.0%)</option>
				
				<option value="file5">github.com/johnny1110/crypto-exchange/controller/orderbooks.go (0.0%)</option>
				
				<option value="file6">github.com/johnny1110/crypto-exchange/controller/orders.go (0.0%)</option>
				
				<option value="file7">github.com/johnny1110/crypto-exchange/controller/resp.go (0.0%)</option>
				
				<option value="file8">github.com/johnny1110/crypto-exchange/controller/users.go (0.0%)</option>
				
				<option value="file9">github.com/johnny1110/crypto-exchange/db.go (0.0%)</option>
				
				<option value="file10">github.com/johnny1110/crypto-exchange/dto/orders.go (0.0%)</option>
				
				<option value="file11">github.com/johnny1110/crypto-exchange/dto/trade.go (0.0%)</option>
				
				<option value="file12">github.com/johnny1110/crypto-exchange/dto/users.go (0.0%)</option>
				
				<option value="file13">github.com/johnny1110/crypto-exchange/engine-v1/exchange/exchange.go (0.0%)</option>
				
				<option value="file14">github.com/johnny1110/crypto-exchange/engine-v1/orderbook/orderbook.go (85.3%)</option>
				
				<option value="file15">github.com/johnny1110/crypto-exchange/engine-v1/user/user.go (0.0%)</option>
				
				<option value="file16">github.com/johnny1110/crypto-exchange/engine-v2/book/book_side.go (83.1%)</option>
				
				<option value="file17">github.com/johnny1110/crypto-exchange/engine-v2/book/order_index.go (86.7%)</option>
				
				<option value="file18">github.com/johnny1110/crypto-exchange/engine-v2/book/orderbook.go (59.5%)</option>
				
				<option value="file19">github.com/johnny1110/crypto-exchange/engine-v2/core/engine.go (0.0%)</option>
				
				<option value="file20">github.com/johnny1110/crypto-exchange/engine-v2/market/market.go (6.2%)</option>
				
				<option value="file21">github.com/johnny1110/crypto-exchange/engine-v2/model/order.go (36.0%)</option>
				
				<option value="file22">github.com/johnny1110/crypto-exchange/engine-v2/util/deque.go (77.0%)</option>
				
				<option value="file23">github.com/johnny1110/crypto-exchange/main.go (0.0%)</option>
				
				<option value="file24">github.com/johnny1110/crypto-exchange/middleware/middleware.go (0.0%)</option>
				
				<option value="file25">github.com/johnny1110/crypto-exchange/repository/impl/balances.go (0.0%)</option>
				
				<option value="file26">github.com/johnny1110/crypto-exchange/repository/impl/orders.go (0.0%)</option>
				
				<option value="file27">github.com/johnny1110/crypto-exchange/repository/impl/trades.go (0.0%)</option>
				
				<option value="file28">github.com/johnny1110/crypto-exchange/repository/impl/users.go (0.0%)</option>
				
				<option value="file29">github.com/johnny1110/crypto-exchange/router.go (0.0%)</option>
				
				<option value="file30">github.com/johnny1110/crypto-exchange/scheduler/lqdt_amm_job.go (0.0%)</option>
				
				<option value="file31">github.com/johnny1110/crypto-exchange/scheduler/market_job.go (0.0%)</option>
				
				<option value="file32">github.com/johnny1110/crypto-exchange/scheduler/orderbook_snapshot_job.go (0.0%)</option>
				
				<option value="file33">github.com/johnny1110/crypto-exchange/security/credential.go (0.0%)</option>
				
				<option value="file34">github.com/johnny1110/crypto-exchange/service/impl/admins.go (0.0%)</option>
				
				<option value="file35">github.com/johnny1110/crypto-exchange/service/impl/amm/amm_strategies.go (0.0%)</option>
				
				<option value="file36">github.com/johnny1110/crypto-exchange/service/impl/amm/provide_liquidity_amm.go (26.9%)</option>
				
				<option value="file37">github.com/johnny1110/crypto-exchange/service/impl/amm/strategy_helper.go (2.1%)</option>
				
				<option value="file38">github.com/johnny1110/crypto-exchange/service/impl/amm/test/fale_orders.go (0.0%)</option>
				
				<option value="file39">github.com/johnny1110/crypto-exchange/service/impl/amm/test/mock.go (18.2%)</option>
				
				<option value="file40">github.com/johnny1110/crypto-exchange/service/impl/balances.go (0.0%)</option>
				
				<option value="file41">github.com/johnny1110/crypto-exchange/service/impl/caches.go (0.0%)</option>
				
				<option value="file42">github.com/johnny1110/crypto-exchange/service/impl/markets.go (0.0%)</option>
				
				<option value="file43">github.com/johnny1110/crypto-exchange/service/impl/orderbooks.go (0.0%)</option>
				
				<option value="file44">github.com/johnny1110/crypto-exchange/service/impl/orders.go (0.0%)</option>
				
				<option value="file45">github.com/johnny1110/crypto-exchange/service/impl/txn.go (0.0%)</option>
				
				<option value="file46">github.com/johnny1110/crypto-exchange/service/impl/users.go (0.0%)</option>
				
				<option value="file47">github.com/johnny1110/crypto-exchange/service/serviceHelper/helpers.go (0.0%)</option>
				
				<option value="file48">github.com/johnny1110/crypto-exchange/service/serviceHelper/settlement.go (0.0%)</option>
				
				<option value="file49">github.com/johnny1110/crypto-exchange/settings/cache_key.go (0.0%)</option>
				
				<option value="file50">github.com/johnny1110/crypto-exchange/settings/settings.go (0.0%)</option>
				
				<option value="file51">github.com/johnny1110/crypto-exchange/startup_helper.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package chainUtil

import (
        "context"
        "crypto/ecdsa"
        "errors"
        "fmt"
        "github.com/ethereum/go-ethereum/common"
        "github.com/ethereum/go-ethereum/core/types"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethclient"
        "math"
        "math/big"
)

// standard ERC-20 ABI snippet with only balanceOf
const erc20ABI = `[{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"}]`

// tokenAddresses maps symbol to its mainnet contract address
var tokenAddresses = map[string]string{
        "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        // add more tokens here as needed...
}

func TransferToken(client *ethclient.Client, symbol string, amount float64, to string, privateKey ecdsa.PrivateKey) <span class="cov0" title="0">{
        if !checkSymbol(symbol) </span><span class="cov0" title="0">{
                panic("symbol check failed")</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        publicKey := privateKey.Public()
        publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                panic("cannot assert type: publicKey is not of type *ecdsa.PublicKey")</span>
        }

        <span class="cov0" title="0">fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
        toAddress := common.HexToAddress(to)

        switch symbol </span>{
        case "ETH":<span class="cov0" title="0">
                transferETH(client, fromAddress, toAddress, &amp;privateKey, amount, &amp;ctx)
                break</span>
        default:<span class="cov0" title="0">
                transferERC20(client, fromAddress, toAddress, &amp;privateKey, amount, &amp;ctx)</span>
        }

}

func transferETH(client *ethclient.Client, fromAddress, toAddress common.Address, privateKey *ecdsa.PrivateKey, amount float64, ctx *context.Context) <span class="cov0" title="0">{
        nonce, err := client.PendingNonceAt(context.Background(), fromAddress)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Convert amount from ETH to Wei
        <span class="cov0" title="0">ethToWei := new(big.Float).Mul(big.NewFloat(amount), big.NewFloat(math.Pow10(18)))
        value := new(big.Int)
        ethToWei.Int(value) // convert *big.Float to *big.Int (truncating)

        // Set gas parameters
        gasLimit := uint64(21000) // standard for ETH transfer
        gasPrice, err := client.SuggestGasPrice(*ctx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">tx := types.NewTransaction(nonce, toAddress, value, gasLimit, gasPrice, nil)

        chainID := big.NewInt(1337)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">err = client.SendTransaction(context.Background(), signedTx)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("tx sent: %s \n", signedTx.Hash().Hex())

        fromBalanceAfter, _ := client.BalanceAt(*ctx, fromAddress, nil)
        toBalanceAfter, _ := client.BalanceAt(*ctx, toAddress, nil)
        fmt.Println("From Address After Txn Balance:", fromBalanceAfter)
        fmt.Println("To Address After Txn Balance:", toBalanceAfter)</span>
        // TODO: seems like toWalletAddress didn't received the ETH, idk why, maybe let find it out next week.
}

func transferERC20(client *ethclient.Client, address common.Address, address2 common.Address, e *ecdsa.PrivateKey, amount float64, ctx *context.Context) {<span class="cov0" title="0">
        // TODO
}</span>

// CheckBalance return address balance is greater than amount
func CheckBalance(client *ethclient.Client, symbol string, addressStr string, amount float64) bool <span class="cov0" title="0">{
        if !checkSymbol(symbol) </span><span class="cov0" title="0">{
                panic("symbol check failed")</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        address := common.HexToAddress(addressStr)

        switch symbol </span>{
        case "ETH":<span class="cov0" title="0">
                // native ETH balance at latest block
                rawBalance, err := client.BalanceAt(ctx, address, nil)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                //fmt.Println("Address: %s, ETH Balance: %s", address.Hex(), rawBalance)

                // convert Wei -&gt; Ether
                <span class="cov0" title="0">balFloat := new(big.Float).Quo(
                        new(big.Float).SetInt(rawBalance),
                        big.NewFloat(math.Pow10(18)),
                )
                return balFloat.Cmp(big.NewFloat(amount)) &gt;= 0</span>

        default:<span class="cov0" title="0">
                // TODO: implement check ERC-20 token balance
                return true</span>
        }
}

func QueryBalance(client *ethclient.Client, symbol string, addressStr string) (float64, error) <span class="cov0" title="0">{
        if !checkSymbol(symbol) </span><span class="cov0" title="0">{
                panic("symbol check failed")</span>
        }

        <span class="cov0" title="0">ctx := context.Background()
        address := common.HexToAddress(addressStr)

        switch symbol </span>{
        case "ETH":<span class="cov0" title="0">
                rawBalance, err := client.BalanceAt(ctx, address, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                // convert Wei -&gt; Ether
                <span class="cov0" title="0">balFloat := new(big.Float).Quo(
                        new(big.Float).SetInt(rawBalance),
                        big.NewFloat(math.Pow10(18)),
                )

                f64, _ := balFloat.Float64() // convert *big.Float to float64 (lossy but fine for display)
                return f64, nil</span>

        default:<span class="cov0" title="0">
                // TODO: Add ERC-20 support
                return 0, errors.New("token not supported yet")</span>
        }
}

// checkSymbol Only support ETH USDT now.
func checkSymbol(symbol string) bool <span class="cov0" title="0">{
        return symbol == "ETH" || symbol == "USDT"
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package container

import (
        "database/sql"
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/johnny1110/crypto-exchange/repository"
        repositoryImpl "github.com/johnny1110/crypto-exchange/repository/impl"
        "github.com/johnny1110/crypto-exchange/scheduler"
        "github.com/johnny1110/crypto-exchange/security"
        "github.com/johnny1110/crypto-exchange/service"
        serviceImpl "github.com/johnny1110/crypto-exchange/service/impl"
        "github.com/johnny1110/crypto-exchange/service/impl/amm"
        "log"
        "net/http"
        "time"
)

// Container including all service and repo
type Container struct {
        // Database
        DB *sql.DB

        // Repositories
        UserRepo    repository.IUserRepository
        BalanceRepo repository.IBalanceRepository
        OrderRepo   repository.IOrderRepository
        TradeRepo   repository.ITradeRepository

        // Services
        UserService       service.IUserService
        BalanceService    service.IBalanceService
        OrderService      service.IOrderService
        OrderBookService  service.IOrderBookService
        AdminService      service.IAdminService
        CacheService      service.ICacheService
        MarketDataService service.IMarketDataService

        // Cache and Security
        CredentialCache *security.CredentialCache
        MatchingEngine  *core.MatchingEngine

        // Scheduler
        MarketDataScheduler        scheduler.Scheduler
        OrderBookSnapshotScheduler scheduler.Scheduler
        LQDTScheduler              scheduler.Scheduler

        // Proxy
        AmmExFuncProxy amm.IAmmExchangeFuncProxy
}

// NewContainer do DI
func NewContainer(db *sql.DB, engine *core.MatchingEngine) *Container <span class="cov0" title="0">{
        c := &amp;Container{
                DB:             db,
                MatchingEngine: engine,
        }

        // init cache
        c.CredentialCache = security.NewCredentialCache()

        // init repositories
        c.initRepositories()

        // init services
        c.initServices()

        // init proxy()
        c.initProxy()

        // init Scheduler
        c.initScheduler()

        return c
}</span>

func (c *Container) initRepositories() <span class="cov0" title="0">{
        c.UserRepo = repositoryImpl.NewUserRepository()
        c.BalanceRepo = repositoryImpl.NewBalanceRepository()
        c.OrderRepo = repositoryImpl.NewOrderRepository()
        c.TradeRepo = repositoryImpl.NewTradeRepository()
}</span>

func (c *Container) initServices() <span class="cov0" title="0">{
        c.UserService = serviceImpl.NewIUserService(c.DB, c.UserRepo, c.BalanceRepo, c.CredentialCache)
        c.OrderService = serviceImpl.NewIOrderService(c.DB, c.MatchingEngine, c.OrderRepo, c.TradeRepo, c.BalanceRepo)
        c.OrderBookService = serviceImpl.NewIOrderBookService(c.MatchingEngine)
        c.AdminService = serviceImpl.NewIAdminService(c.DB, c.UserRepo, c.BalanceRepo, c.OrderService)
        c.CacheService = serviceImpl.NewCacheService()
        c.MarketDataService = serviceImpl.NewMarketDataService(c.DB, c.TradeRepo, c.CacheService)
        c.BalanceService = serviceImpl.NewIBalanceService(c.DB, c.UserRepo, c.BalanceRepo, c.MarketDataService)
}</span>

// Cleanup clean
func (c *Container) Cleanup() <span class="cov0" title="0">{
        if c.DB != nil </span><span class="cov0" title="0">{
                if err := c.DB.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error closing database: %v", err)
                }</span>
        }
}

func (c *Container) initScheduler() <span class="cov0" title="0">{
        c.MarketDataScheduler = scheduler.NewMarketDataScheduler(c.MarketDataService, c.CacheService, 30*time.Second)
        c.OrderBookSnapshotScheduler = scheduler.NewOrderBookSnapshotScheduler(c.MatchingEngine, 300*time.Millisecond)
        c.LQDTScheduler = scheduler.NewLQDTScheduler(c.AmmExFuncProxy, c.UserService, 30*time.Second)
}</span>

func (c *Container) initProxy() <span class="cov0" title="0">{
        c.AmmExFuncProxy = amm.NewAmmExchangeFuncProxyImpl(
                c.OrderBookService, c.BalanceService, c.OrderService, c.UserService,
                &amp;http.Client{
                        Timeout: 30 * time.Second,
                })
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/service"
        "net/http"
)

type AdminController struct {
        adminService service.IAdminService
}

func (c AdminController) ManualAdjustment(context *gin.Context) <span class="cov0" title="0">{
        var req dto.SettlementReq
        if err := context.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeErrorAndMsg(INVALID_PARAMS, "input parameter error"))
                return
        }</span>

        <span class="cov0" title="0">err := c.adminService.Settlement(context.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(INVALID_PARAMS, err))
                return
        }</span>

        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(nil))</span>
}

func (c AdminController) TestMakeMarket(context *gin.Context) <span class="cov0" title="0">{
        // TODO: implement auto market maker logic.
        context.JSON(http.StatusBadRequest, HandleCodeErrorAndMsg(FUNC_NOT_IMPLEMENT, "func not support yet"))
        return
}</span>

func NewAdminController(adminService service.IAdminService) *AdminController <span class="cov0" title="0">{
        return &amp;AdminController{
                adminService: adminService,
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/service"
        "net/http"
)

type BalanceController struct {
        balanceService service.IBalanceService
}

func (c BalanceController) GetBalances(context *gin.Context) <span class="cov0" title="0">{
        userId := context.MustGet("userId").(string)
        balances, err := c.balanceService.GetBalances(context.Request.Context(), userId)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(QUERY_BALANCE_ERROR, err))
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(balances))</span>
}

func NewBalanceController(balanceService service.IBalanceService) *BalanceController <span class="cov0" title="0">{
        return &amp;BalanceController{
                balanceService: balanceService,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/service"
        "net/http"
)

type MarketDataController struct {
        marketDataService service.IMarketDataService
}

func NewMarketDataController(marketDataService service.IMarketDataService) *MarketDataController <span class="cov0" title="0">{
        return &amp;MarketDataController{marketDataService: marketDataService}
}</span>

func (mc MarketDataController) GetAllMarketsData(ctx *gin.Context) <span class="cov0" title="0">{
        data, err := mc.marketDataService.GetAllMarketData()

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusInternalServerError, HandleError(err))
                return
        }</span>

        <span class="cov0" title="0">var markets []interface{}
        for _, marketData := range data </span><span class="cov0" title="0">{
                markets = append(markets, marketData)
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, HandleSuccess(markets))</span>
}

func (mc MarketDataController) GetMarketsData(ctx *gin.Context) <span class="cov0" title="0">{
        market := ctx.Param("market")
        if market == "" </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>
        <span class="cov0" title="0">data, err := mc.marketDataService.GetMarketData(market)

        if err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, HandleError(err))
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, HandleSuccess(data))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/service"
        "net/http"
)

type OrderBookController struct {
        service service.IOrderBookService
}

func (c OrderBookController) OrderbooksSnapshot(context *gin.Context) <span class="cov0" title="0">{
        market := context.Param("market")
        snapshot, err := c.service.GetSnapshot(context.Request.Context(), market)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(SNAPSHOT_ERROR, err))
                return
        }</span>

        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(snapshot))</span>
}

func NewOrderBookController(service service.IOrderBookService) *OrderBookController <span class="cov0" title="0">{
        return &amp;OrderBookController{
                service: service,
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/labstack/gommon/log"
        "net/http"
)

type OrderController struct {
        orderService service.IOrderService
}

func NewOrderController(orderService service.IOrderService) *OrderController <span class="cov0" title="0">{
        return &amp;OrderController{
                orderService: orderService,
        }
}</span>

func (c OrderController) PlaceOrder(context *gin.Context) <span class="cov0" title="0">{
        user := context.MustGet("user").(*dto.User)
        market := context.Param("market") // router is /:market/order

        if user == nil || market == "" </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">var req dto.OrderReq
        if err := context.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">log.Infof("[OrderContrller] Placing order: market:[%s], user:[%s], req: %v", market, user.Username, req)

        result, err := c.orderService.PlaceOrder(context.Request.Context(), market, user, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(PLACE_ORDER_ERROR, err))
                return
        }</span>

        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(result))</span>
}

func (c OrderController) CancelOrder(context *gin.Context) <span class="cov0" title="0">{
        userID := context.MustGet("userId").(string)
        orderID := context.Param("orderId")

        if userID == "" || orderID == "" </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">log.Infof("[OrderController] Canceling order: userID:[%s], orderID: [%s]", userID, orderID)

        order, err := c.orderService.CancelOrder(context.Request.Context(), userID, orderID)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(CANCEL_ORDER_ERROR, err))
                return
        }</span>

        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(order))</span>
}

func (c OrderController) GetOrders(ctx *gin.Context) <span class="cov0" title="0">{
        userID := ctx.MustGet("userId").(string)
        var query dto.GetOrdersQueryReq
        if err := ctx.ShouldBindQuery(&amp;query); err != nil </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">query.UserID = userID

        resp, err := c.orderService.PaginationQuery(ctx.Request.Context(), &amp;query)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[OrderController] failed to PaginationQuery, error: %v", err)
                ctx.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">ctx.JSON(http.StatusOK, HandleSuccess(resp))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controller

import (
        "time"
)

type Resp struct {
        Code      MessageCode `json:"code"`
        Msg       string      `json:"message"`
        Timestamp int64       `json:"timestamp"`
        Data      any         `json:"data"`
}

func HandleError(err error) any <span class="cov0" title="0">{
        return &amp;Resp{
                Code:      SYSTEM_ERROR,
                Msg:       err.Error(),
                Timestamp: time.Now().UnixMilli(),
        }
}</span>

func HandleCodeError(code MessageCode, err error) any <span class="cov0" title="0">{
        return &amp;Resp{
                Code:      code,
                Msg:       err.Error(),
                Timestamp: time.Now().UnixMilli(),
        }
}</span>

func HandleCodeErrorAndMsg(code MessageCode, msg string) any <span class="cov0" title="0">{
        return &amp;Resp{
                Code:      code,
                Msg:       msg,
                Timestamp: time.Now().UnixMilli(),
        }
}</span>

func HandleSuccess(data any) any <span class="cov0" title="0">{
        return &amp;Resp{
                Code:      SUCCESS,
                Msg:       "success",
                Data:      data,
                Timestamp: time.Now().UnixMilli(),
        }
}</span>

func HandleInvalidInput() any <span class="cov0" title="0">{
        return HandleCodeErrorAndMsg(INVALID_PARAMS, "invalid input")
}</span>

type MessageCode string

const (
        SUCCESS MessageCode = "0000000"

        // common error: 1000001 ~ 1999999
        INVALID_PARAMS     = "1000001"
        FUNC_NOT_IMPLEMENT = "1000009"

        // users : 2000000 ~ 2999999
        REGISTER_ERROR      = "2000001"
        LOGIN_ERROR         = "2000002"
        USER_DATA_NOT_FOUND = "2000003"

        // orders : 3000000 ~ 3999999
        PLACE_ORDER_ERROR  = "3000001"
        CANCEL_ORDER_ERROR = "3000002"

        // balances : 4000000 ~ 4999999
        QUERY_BALANCE_ERROR = "4000001"

        // orderBooks: 5000000 ~ 5999999
        SNAPSHOT_ERROR = "5000001"

        BAD_REQUEST   MessageCode = "9000001"
        ACCESS_DENIED MessageCode = "9900001"
        SYSTEM_ERROR  MessageCode = "9999999"
)
</pre>
		
		<pre class="file" id="file8" style="display: none">package controller

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/service"
        "net/http"
)

type UserController struct {
        userService service.IUserService
}

func (c UserController) Register(context *gin.Context) <span class="cov0" title="0">{
        var req dto.RegisterReq
        if err := context.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>

        <span class="cov0" title="0">userId, err := c.userService.Register(context.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(REGISTER_ERROR, err))
                return
        }</span>

        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(map[string]any{"user_id": userId}))
        return</span>
}

func (c UserController) Login(context *gin.Context) <span class="cov0" title="0">{
        var req dto.LoginReq
        if err := context.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleInvalidInput())
                return
        }</span>
        <span class="cov0" title="0">token, err := c.userService.Login(context.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(LOGIN_ERROR, err))
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(map[string]any{"token": token}))
        return</span>
}

func (c UserController) GetProfile(context *gin.Context) <span class="cov0" title="0">{
        userId := context.MustGet("userId").(string)
        user, err := c.userService.GetUser(context.Request.Context(), userId)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(USER_DATA_NOT_FOUND, err))
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(user))
        return</span>
}

func (c UserController) Logout(context *gin.Context) <span class="cov0" title="0">{
        token := context.MustGet("token").(string)
        err := c.userService.Logout(context.Request.Context(), token)
        if err != nil </span><span class="cov0" title="0">{
                context.JSON(http.StatusBadRequest, HandleCodeError(USER_DATA_NOT_FOUND, err))
                return
        }</span>
        <span class="cov0" title="0">context.JSON(http.StatusOK, HandleSuccess(nil))
        return</span>
}

func NewUserController(userService service.IUserService) *UserController <span class="cov0" title="0">{
        return &amp;UserController{
                userService: userService,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "database/sql"
        "fmt"
        "github.com/labstack/gommon/log"
        _ "modernc.org/sqlite"
)

// initDB if testMode = true, everytime startup the app, it will rebuild database with schema and prepare mock data.
func initDB(testMode bool) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("sqlite", "/Users/johnny.wang/frizo/crypto-exchange/dist/exg.db")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxOpenConns(1)
        db.SetMaxIdleConns(1)

        // Test the connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Infof("Database initialized successfully")

        // Run SQL files on startup if testMode
        if testMode </span><span class="cov0" title="0">{
                if err := runSQLFilesWithTransaction(db); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to run SQL files: %w", err)
                }</span>
                <span class="cov0" title="0">log.Infof("DB schema and testing data initialized successfully")</span>
        }

        <span class="cov0" title="0">return db, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package dto

import (
        "encoding/json"
        "fmt"
        "github.com/google/uuid"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "time"
)

type Order struct {
        ID            string            `json:"id"`
        UserID        string            `json:"-"`
        Market        string            `json:"market"`
        Side          model.Side        `json:"side"`
        Price         float64           `json:"-"`
        OriginalSize  float64           `json:"original_size"`
        RemainingSize float64           `json:"remaining_size"`
        QuoteAmount   float64           `json:"quote_amount"`
        AvgDealtPrice float64           `json:"avg_dealt_price"`
        Type          model.OrderType   `json:"type"`
        Mode          model.Mode        `json:"mode"`
        Status        model.OrderStatus `json:"status"`
        FeeRate       float64           `json:"-"`
        Fees          float64           `json:"fees"`
        FeeAsset      string            `json:"fee_asset"`
        CreatedAt     time.Time         `json:"-"`
        UpdatedAt     time.Time         `json:"-"`
}

func (o Order) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Order

        // Create the struct with conditional price field
        result := struct {
                *Alias
                Price     *float64 `json:"price,omitempty"`
                FeeRate   string   `json:"fee_rate"`
                CreatedAt int64    `json:"created_at"`
                UpdatedAt int64    `json:"updated_at"`
        }{
                Alias:     (*Alias)(&amp;o),
                FeeRate:   fmt.Sprintf("%.4f%%", o.FeeRate*100), // properly format percentage
                CreatedAt: o.CreatedAt.UnixMilli(),
                UpdatedAt: o.UpdatedAt.UnixMilli(),
        }

        // Only include price if it's &gt; 0
        if o.Price &gt; 0 </span><span class="cov0" title="0">{
                result.Price = &amp;o.Price
        }</span>

        <span class="cov0" title="0">return json.Marshal(result)</span>
}

func (o Order) ToEngineOrder() *model.Order <span class="cov0" title="0">{
        return &amp;model.Order{
                ID:            o.ID,
                UserID:        o.UserID,
                Side:          o.Side,
                Price:         o.Price,
                OriginalSize:  o.OriginalSize,
                RemainingSize: o.RemainingSize,
                Mode:          o.Mode,
                FeeRate:       o.FeeRate,
                Timestamp:     o.CreatedAt,
        }
}</span>

// OrderBuilder provides a fluent interface for building orders
type OrderBuilder struct {
        order *Order
}

// NewOrderBuilder creates a new order builder
func NewOrderBuilder() *OrderBuilder <span class="cov0" title="0">{
        return &amp;OrderBuilder{
                order: &amp;Order{
                        ID:        uuid.NewString(),
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                },
        }
}</span>

func (b *OrderBuilder) WithMarket(market string) *OrderBuilder <span class="cov0" title="0">{
        b.order.Market = market
        return b
}</span>

func (b *OrderBuilder) WithUser(userID string) *OrderBuilder <span class="cov0" title="0">{
        b.order.UserID = userID
        return b
}</span>

func (b *OrderBuilder) WithSide(side model.Side) *OrderBuilder <span class="cov0" title="0">{
        b.order.Side = side
        return b
}</span>

func (b *OrderBuilder) WithType(orderType model.OrderType) *OrderBuilder <span class="cov0" title="0">{
        b.order.Type = orderType
        return b
}</span>

func (b *OrderBuilder) WithMode(mode model.Mode) *OrderBuilder <span class="cov0" title="0">{
        b.order.Mode = mode
        return b
}</span>

func (b *OrderBuilder) WithPrice(price float64) *OrderBuilder <span class="cov0" title="0">{
        b.order.Price = price
        return b
}</span>

func (b *OrderBuilder) WithSize(size float64) *OrderBuilder <span class="cov0" title="0">{
        b.order.OriginalSize = size
        b.order.RemainingSize = size
        return b
}</span>

func (b *OrderBuilder) WithQuoteAmount(amount float64) *OrderBuilder <span class="cov0" title="0">{
        b.order.QuoteAmount = amount
        return b
}</span>

func (b *OrderBuilder) WithFeeRate(feeRate float64, feeAsset string) *OrderBuilder <span class="cov0" title="0">{
        b.order.FeeRate = feeRate
        b.order.FeeAsset = feeAsset
        return b
}</span>

func (b *OrderBuilder) Build() *Order <span class="cov0" title="0">{
        b.order.Status = model.ORDER_STATUS_NEW
        return b.order
}</span>

// PlaceOrderContext encapsulates all order placement context
type PlaceOrderContext struct {
        Market   string
        UserID   string
        Request  *OrderReq
        FeeRate  float64
        FeeAsset string
        OrderDTO *Order
        Assets   *AssetDetails
        Trades   []book.Trade
}

func (c *PlaceOrderContext) SyncTradeResult(engineOrder *model.Order, trades []book.Trade) <span class="cov0" title="0">{
        c.OrderDTO.RemainingSize = engineOrder.RemainingSize
        c.OrderDTO.Status = engineOrder.GetStatus()
        c.Trades = trades
}</span>

// AssetDetails holds asset-related information
type AssetDetails struct {
        BaseAsset   string
        QuoteAsset  string
        FreezeAsset string
        FreezeAmt   float64
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package dto

import (
        "encoding/json"
        "time"
)

type PlaceOrderResult struct {
        Matches []*Match `json:"matches"`
        Order   Order    `json:"order"`
}

type Match struct {
        Price     float64   `json:"price"`
        Size      float64   `json:"size"`
        Timestamp time.Time `json:"-"`
}

func (m Match) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Match
        return json.Marshal(&amp;struct {
                *Alias
                Timestamp int64 `json:"timestamp"`
        }{
                Alias:     (*Alias)(&amp;m),
                Timestamp: m.Timestamp.UnixMilli(),
        })
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package dto

import (
        "encoding/json"
        "time"
)

type User struct {
        ID           string    `json:"id"`
        Username     string    `json:"username"`
        PasswordHash string    `json:"-"`
        VipLevel     int       `json:"vip_level"`
        MakerFee     float64   `json:"maker_fee"`
        TakerFee     float64   `json:"taker_fee"`
        CreatedAt    time.Time `json:"created_at"`
}

func (u User) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias User
        return json.Marshal(&amp;struct {
                *Alias
                CreatedAt int64 `json:"created_at"`
        }{
                Alias:     (*Alias)(&amp;u),
                CreatedAt: u.CreatedAt.UnixMilli(),
        })
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package exchange

import (
        "crypto/ecdsa"
        "encoding/json"
        "errors"
        "fmt"
        "github.com/ethereum/go-ethereum/crypto"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/johnny1110/crypto-exchange/engine-v1/orderbook"
        "github.com/johnny1110/crypto-exchange/engine-v1/user"
        "log"
        "net/http"
        "strconv"
        "time"

        "github.com/johnny1110/crypto-exchange/chainUtil"
        "github.com/labstack/echo/v4"
)

type (
        Market    string
        OrderType string

        Exchange struct {
                // users - key: orderId
                userIdMapUser    map[int64]*user.User
                orderIdMapUserId map[int64]int64
                orderbooks       map[Market]*orderbook.OrderBook
                address          string
                privateKey       *ecdsa.PrivateKey

                ethClient *ethclient.Client
        }

        PlaceOrderRequest struct {
                UserID   int64     `json:"userId"`
                Username string    `json:"username"`
                Market   Market    `json:"market"`
                Type     OrderType `json:"type"`
                Bid      bool      `json:"bid"`
                Size     float64   `json:"size"`
                Price    float64   `json:"price"`
        }

        Order struct {
                ID        int64
                Price     float64 `json:"price"`
                Size      float64 `json:"size"`
                Bid       bool    `json:"bid"`
                Timestamp int64   `json:"timestamp"`
        }

        OrderBookDisplay struct {
                Asks            []*Order
                Bids            []*Order
                TotalAsksVolume float64
                TotalBidsVolume float64
        }

        RegisterUserRequest struct {
                Username   string `json:"username"`
                Address    string `json:"address"`
                PrivateKey string `json:"privateKey"`
        }
)

const (
        MarketBTC   Market    = "BTC"
        MarketETH   Market    = "ETH"
        LimitOrder  OrderType = "LIMIT"
        MarketOrder OrderType = "MARKET"
)

func NewExchange(ethClient *ethclient.Client, hotWalletAddress, hotWalletPrivateKey string) (*Exchange, error) <span class="cov0" title="0">{
        privateKey, err := crypto.HexToECDSA(hotWalletPrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Exchange{
                userIdMapUser:    make(map[int64]*user.User),
                orderIdMapUserId: make(map[int64]int64),
                orderbooks:       make(map[Market]*orderbook.OrderBook),
                address:          hotWalletAddress,
                privateKey:       privateKey,
                ethClient:        ethClient,
        }, nil</span>
}

func (ex *Exchange) InitOrderbooks() <span class="cov0" title="0">{
        ex.orderbooks[MarketBTC] = orderbook.NewOrderBook("BTC")
        ex.orderbooks[MarketETH] = orderbook.NewOrderBook("ETH")
}</span>
func (ex *Exchange) HandlePlaceOrder(c echo.Context) error <span class="cov0" title="0">{

        var placeOrderData PlaceOrderRequest
        if err := json.NewDecoder(c.Request().Body).Decode(&amp;placeOrderData); err != nil </span><span class="cov0" title="0">{
                return c.JSON(400, map[string]any{"msg": "invalid request body"})
        }</span>

        <span class="cov0" title="0">if placeOrderData.UserID == 0 </span><span class="cov0" title="0">{
                return c.JSON(400, map[string]any{"msg": "userId is required"})
        }</span>

        <span class="cov0" title="0">market := Market(placeOrderData.Market)
        orderType := OrderType(placeOrderData.Type)
        ob := ex.orderbooks[market]

        if ob == nil </span><span class="cov0" title="0">{
                return c.JSON(400, "{'error': 'invalid market'}")
        }</span>

        <span class="cov0" title="0">order := orderbook.NewOrder(placeOrderData.Bid, placeOrderData.Size, placeOrderData.UserID)

        switch orderType </span>{
        case LimitOrder:<span class="cov0" title="0">
                err := ex.handlePlaceLimitOrder(ob, order, placeOrderData.Price)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        return c.JSON(http.StatusBadRequest, map[string]any{"msg": "failed to place limit order"})
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]any{"msg": "limit order placed"})</span>
        case MarketOrder:<span class="cov0" title="0">
                matches, respMatchOrders := ex.handlePlaceMarketOrder(ob, order, placeOrderData.Price)

                // handle matches (token transfer)
                if err := ex.handleMatches(matches); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]any{"matches": respMatchOrders})</span>
        default:<span class="cov0" title="0">
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "missing order type"})</span>
        }
}

func (ex *Exchange) HandleGetOrderBook(c echo.Context) error <span class="cov0" title="0">{
        //parse market from URL
        market := c.Param("market")
        ob, ok := ex.orderbooks[Market(market)]
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "invalid market"})
        }</span>
        <span class="cov0" title="0">fmt.Println("orderbook:", ob)
        //convert orderbook to DisplayData

        orderBookDisplay := OrderBookDisplay{
                Asks:            []*Order{},
                Bids:            []*Order{},
                TotalAsksVolume: ob.AskTotalVolume(),
                TotalBidsVolume: ob.BidTotalVolume(),
        }

        for _, asks := range ob.Asks() </span><span class="cov0" title="0">{
                for _, order := range asks.Orders </span><span class="cov0" title="0">{
                        orderBookDisplay.Asks = append(orderBookDisplay.Asks, &amp;Order{
                                ID:        order.ID,
                                Price:     asks.Price,
                                Size:      order.Size,
                                Bid:       order.Bid,
                                Timestamp: order.Timestamp,
                        })
                }</span>
        }

        <span class="cov0" title="0">for _, bids := range ob.Bids() </span><span class="cov0" title="0">{
                for _, order := range bids.Orders </span><span class="cov0" title="0">{
                        orderBookDisplay.Bids = append(orderBookDisplay.Bids, &amp;Order{
                                ID:        order.ID,
                                Price:     bids.Price,
                                Size:      order.Size,
                                Bid:       order.Bid,
                                Timestamp: order.Timestamp,
                        })
                }</span>

        }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, orderBookDisplay)</span>
}

func (ex *Exchange) HandleDeleteOrder(c echo.Context) error <span class="cov0" title="0">{
        marketStr := c.Param("market")
        orderIdStr := c.Param("id")

        // TODO: should ensure request sender is order owner (secure)

        market := Market(marketStr)
        orderId, _ := strconv.Atoi(orderIdStr)
        ob := ex.orderbooks[market]
        order := ob.GetOrderById(int64(orderId))
        ob.CancelOrder(order)

        symbol := ob.Symbol
        userId := order.UserID
        user := ex.userIdMapUser[userId]
        fmt.Println("[HandleDeleteOrder] refund to user:", user.Username)
        fmt.Println("[HandleDeleteOrder] refund to address:", user.Address)
        fmt.Println("[HandleDeleteOrder] refund size:", order.Size)
        chainUtil.TransferToken(ex.ethClient, symbol, order.Size, user.Address, *ex.privateKey)

        return c.JSON(http.StatusOK, map[string]any{"msg": "OK"})
}</span>

func (ex *Exchange) HandleGetOrderIds(c echo.Context) error <span class="cov0" title="0">{
        marketStr := c.Param("market")
        market := Market(marketStr)
        ob := ex.orderbooks[market]

        return c.JSON(http.StatusOK, map[string]any{"msg": ob.GetLimitOrderIds()})

}</span>

func (ex *Exchange) handlePlaceLimitOrder(ob *orderbook.OrderBook, order *orderbook.Order, price float64) error <span class="cov0" title="0">{
        user := ex.userIdMapUser[order.UserID]
        if user == nil </span><span class="cov0" title="0">{
                return errors.New("user not found by ID")
        }</span>

        // check user balance logic here.
        <span class="cov0" title="0">ex.checkUserBalance(user, order, price, ob.Symbol)
        amount := order.Size
        ex.transferToken(ob.Symbol, amount, ex.address, *user.PrivateKey)

        if price != 0 </span><span class="cov0" title="0">{
                ob.PlaceLimitOrder(price, order)
                return nil
        }</span> else<span class="cov0" title="0"> {
                // raise error
                return errors.New("limit order price can not be zero")
        }</span>
}

func (ex *Exchange) handlePlaceMarketOrder(ob *orderbook.OrderBook, order *orderbook.Order, price float64) ([]orderbook.Match, []*Order) <span class="cov0" title="0">{
        matches := ob.PlaceMarketOrder(order)

        respMatchOrders := make([]*Order, 0, len(matches))
        for _, match := range matches </span><span class="cov0" title="0">{
                // extract match order bid or ask (if the order is a bid, the match order is an ask)
                isBid := !order.Bid
                // extract match order's ID
                var matchOrderId int64 = 0
                if isBid </span><span class="cov0" title="0">{
                        matchOrderId = match.Bid.ID
                }</span> else<span class="cov0" title="0"> {
                        matchOrderId = match.Ask.ID
                }</span>

                <span class="cov0" title="0">respMatchOrders = append(respMatchOrders, &amp;Order{
                        Price:     match.Price,
                        Size:      match.SizeFilled,
                        Timestamp: time.Now().UnixNano(),
                        Bid:       isBid,
                        ID:        matchOrderId,
                })</span>
        }
        <span class="cov0" title="0">return matches, respMatchOrders</span>
}

func (ex *Exchange) handleMatches(matches []orderbook.Match) error <span class="cov0" title="0">{
        return nil
}</span>

func (ex *Exchange) checkUserBalance(user *user.User, order *orderbook.Order, price float64, tokenSymbol string) bool <span class="cov0" title="0">{
        if order.Bid </span><span class="cov0" title="0">{
                // buy order should check user's USDT balance price*size
                amount := order.Size * price
                log.Println("[checkUserBalance] check user", user.Username, "USDT balance, should greater than ", amount)
                // check user USDT balance
                chainUtil.CheckBalance(ex.ethClient, "USDT", user.Address, amount)
                return true
        }</span> else<span class="cov0" title="0"> {
                // sell order should check user's ERC20 token balance
                log.Println("[checkUserBalance] check user ", user.Username, ", ", tokenSymbol, " balance, should greater than ", order.Size)
                // check user ERC20 Token size (symbol &amp; size)
                chainUtil.CheckBalance(ex.ethClient, tokenSymbol, user.Address, order.Size)
                return true
        }</span>
}

func (ex *Exchange) RegisterUser(c echo.Context) error <span class="cov0" title="0">{
        var registerUserData RegisterUserRequest
        if err := json.NewDecoder(c.Request().Body).Decode(&amp;registerUserData); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "invalid request body"})
        }</span>

        <span class="cov0" title="0">if registerUserData.Address == "" || registerUserData.Username == "" || registerUserData.PrivateKey == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "missing params"})
        }</span>

        <span class="cov0" title="0">newUser := user.NewUser(registerUserData.Username, registerUserData.Address, registerUserData.PrivateKey)
        ex.userIdMapUser[newUser.UserID] = newUser
        return c.JSON(http.StatusOK, map[string]any{"userId": newUser.UserID})</span>
}

func (ex *Exchange) transferToken(symbol string, amount float64, to string, privateKey ecdsa.PrivateKey) <span class="cov0" title="0">{
        chainUtil.TransferToken(ex.ethClient, symbol, amount, to, privateKey)
}</span>

func (ex *Exchange) QueryBalance(c echo.Context) error <span class="cov0" title="0">{
        userIdStr := c.Param("userId")
        symbol := c.Param("symbol")

        userId, err := strconv.ParseInt(userIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "userId format incorrect"})
        }</span>

        <span class="cov0" title="0">user, ok := ex.userIdMapUser[userId]
        if !ok </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "user not found by ID"})
        }</span>

        <span class="cov0" title="0">balance, err := ex.queryBalance(user, symbol)
        if err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{"msg": "failed to query balance"})
        }</span>
        <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]any{"symbol": symbol, "balance": balance})</span>
}

func (ex *Exchange) queryBalance(user *user.User, symbol string) (float64, error) <span class="cov0" title="0">{
        return chainUtil.QueryBalance(ex.ethClient, symbol, user.Address)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package orderbook

import (
        "fmt"
        "math/rand"
        "sort"
        "time"
)

type Match struct {
        Ask        *Order  `json:"ask"`
        Bid        *Order  `json:"bid"`
        SizeFilled float64 `json:"size_filled"`
        Price      float64 `json:"price"`
}

// &lt;Order&gt; ----------------------------------------------------------
type Order struct {
        ID        int64
        UserID    int64
        Size      float64
        Bid       bool
        Limit     *Limit // to track the limit
        Timestamp int64  // unix nano seconds
}

func (o *Order) IsFilled() bool <span class="cov10" title="17">{
        return o.Size == 0.0
}</span>

func (o *Order) String() string <span class="cov9" title="13">{
        return "Order{" +
                "Size: " + fmt.Sprintf("%f", o.Size) +
                ", Bid: " + fmt.Sprintf("%t", o.Bid) +
                "}"
}</span>

func NewOrder(bid bool, size float64, userId int64) *Order <span class="cov9" title="15">{
        return &amp;Order{
                UserID:    userId,
                ID:        int64(rand.Intn(100000000)),
                Size:      size,
                Bid:       bid,
                Timestamp: time.Now().UnixNano(),
        }
}</span>

// &lt;Limit&gt; ----------------------------------------------------------
// Limit is a group of orders at the same price level
type Limit struct {
        Price       float64
        Orders      Orders
        TotalVolume float64
}

func (limit *Limit) FillOrder(inputMarketOrder *Order) []Match <span class="cov5" title="4">{
        var (
                matches        []Match
                ordersToDelete []*Order
        )

        for _, existingLimitOrder := range limit.Orders </span><span class="cov5" title="4">{
                match := limit.fillOrder(existingLimitOrder, inputMarketOrder)
                matches = append(matches, match)

                limit.TotalVolume -= match.SizeFilled

                if existingLimitOrder.IsFilled() </span><span class="cov3" title="2">{
                        ordersToDelete = append(ordersToDelete, existingLimitOrder)
                }</span>

                <span class="cov5" title="4">if inputMarketOrder.IsFilled() </span><span class="cov3" title="2">{
                        break</span>
                }
        }

        // delete the filled limit orders
        <span class="cov5" title="4">for _, filledLimitOrder := range ordersToDelete </span><span class="cov3" title="2">{
                fmt.Println("Deleting order:", filledLimitOrder, " Bid:", filledLimitOrder.Bid, " Size:", filledLimitOrder.Size, " Price:", filledLimitOrder.Limit.Price)
                limit.deleteOrder(filledLimitOrder)
        }</span>

        <span class="cov5" title="4">return matches</span>
}

func (limit *Limit) fillOrder(orderA, orderB *Order) Match <span class="cov5" title="4">{
        var (
                ask        *Order
                bid        *Order
                sizeFilled float64
        )

        if orderA.Bid </span><span class="cov4" title="3">{
                bid = orderA
                ask = orderB
        }</span> else<span class="cov1" title="1"> {
                bid = orderB
                ask = orderA
        }</span>

        <span class="cov5" title="4">if bid.Size &gt;= ask.Size </span><span class="cov1" title="1">{
                bid.Size -= ask.Size
                sizeFilled = ask.Size
                ask.Size = 0.0
        }</span> else<span class="cov4" title="3"> {
                ask.Size -= bid.Size
                sizeFilled = bid.Size
                bid.Size = 0.0
        }</span>

        <span class="cov5" title="4">return Match{
                Bid:        bid,
                Ask:        ask,
                SizeFilled: sizeFilled,
                Price:      limit.Price,
        }</span>
}

func (limit *Limit) String() string <span class="cov4" title="3">{
        return fmt.Sprintf("Limit:&lt;Price: %.2f, TotalVolume: %.2f&gt;", limit.Price, limit.TotalVolume)
}</span>

func NewLimit(price float64) *Limit <span class="cov7" title="8">{
        return &amp;Limit{
                Price:       price,
                Orders:      []*Order{},
                TotalVolume: 0,
        }
}</span>

func (l *Limit) AddOrder(o *Order) <span class="cov9" title="13">{
        o.Limit = l
        l.Orders = append(l.Orders, o)
        l.TotalVolume += o.Size
}</span>

func (l *Limit) deleteOrder(o *Order) <span class="cov5" title="4">{
        for i := 0; i &lt; len(l.Orders); i++ </span><span class="cov6" title="6">{
                if l.Orders[i] == o </span><span class="cov5" title="4">{
                        // remove the order from the slice
                        l.Orders = append(l.Orders[:i], l.Orders[i+1:]...)
                }</span>
        }
        // gc
        <span class="cov5" title="4">o.Limit = nil
        l.TotalVolume -= o.Size

        // resort the rest of the orders
        sort.Sort(l.Orders)</span>
}

// &lt;OrderBook&gt; ----------------------------------------------------------
type OrderBook struct {
        Symbol string
        asks   []*Limit
        bids   []*Limit

        AskLimits map[float64]*Limit
        BidLimits map[float64]*Limit

        limitOrderIdMap map[int64]*Order
}

func NewOrderBook(symbol string) *OrderBook <span class="cov5" title="4">{
        return &amp;OrderBook{
                Symbol:          symbol,
                asks:            []*Limit{},
                bids:            []*Limit{},
                AskLimits:       make(map[float64]*Limit),
                BidLimits:       make(map[float64]*Limit),
                limitOrderIdMap: make(map[int64]*Order),
        }
}</span>

func (orderBook *OrderBook) PlaceLimitOrder(price float64, order *Order) <span class="cov7" title="9">{
        var limit *Limit

        if order.Bid </span><span class="cov6" title="5">{
                limit = orderBook.BidLimits[price]
        }</span> else<span class="cov5" title="4"> {
                limit = orderBook.AskLimits[price]
        }</span>

        <span class="cov7" title="9">if limit == nil </span><span class="cov7" title="7">{
                limit = NewLimit(price)

                if order.Bid </span><span class="cov5" title="4">{
                        orderBook.bids = append(orderBook.bids, limit)
                        orderBook.BidLimits[price] = limit
                }</span> else<span class="cov4" title="3"> {
                        orderBook.asks = append(orderBook.asks, limit)
                        orderBook.AskLimits[price] = limit
                }</span>
        }

        <span class="cov7" title="9">orderBook.limitOrderIdMap[order.ID] = order
        limit.AddOrder(order)</span>
}

func (orderBook *OrderBook) PlaceMarketOrder(order *Order) []Match <span class="cov3" title="2">{
        var matches = make([]Match, 0)
        var limitToDelete = make([]*Limit, 0)

        if order.Bid </span><span class="cov1" title="1">{
                // buy order need looking for ask limits (Asks() will be ordered by price)
                if order.Size &gt; orderBook.AskTotalVolume() </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Not enough ask vloume [size: %.2f] to fill market order [size: %.2f]", orderBook.AskTotalVolume(), order.Size))</span>
                }

                <span class="cov1" title="1">for _, limit := range orderBook.Asks() </span><span class="cov1" title="1">{
                        match := limit.FillOrder(order)

                        for _, m := range match </span><span class="cov1" title="1">{
                                // need remove ask
                                if m.Ask.IsFilled() </span><span class="cov0" title="0">{
                                        delete(orderBook.limitOrderIdMap, m.Ask.ID)
                                }</span>
                        }

                        <span class="cov1" title="1">matches = append(matches, match...)

                        if len(limit.Orders) == 0 </span><span class="cov0" title="0">{
                                limitToDelete = append(limitToDelete, limit)
                        }</span>

                        <span class="cov1" title="1">if order.IsFilled() </span><span class="cov1" title="1">{
                                break</span>
                        }
                }

                <span class="cov1" title="1">for _, limit := range limitToDelete </span><span class="cov0" title="0">{
                        orderBook.clearLimit(false, limit)
                }</span>

        } else<span class="cov1" title="1"> {
                // sell order need looking for bid limits (Bids() will be ordered by price)
                if (order.Size) &gt; orderBook.BidTotalVolume() </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("Not enough bid vloume [size: %.2f] to fill market order [size: %.2f]", orderBook.BidTotalVolume(), order.Size))</span>
                }
                <span class="cov1" title="1">for _, limit := range orderBook.Bids() </span><span class="cov4" title="3">{

                        match := limit.FillOrder(order)

                        for _, m := range match </span><span class="cov4" title="3">{
                                // need remove bid
                                if m.Bid.IsFilled() </span><span class="cov3" title="2">{
                                        delete(orderBook.limitOrderIdMap, m.Bid.ID)
                                }</span>
                        }

                        <span class="cov4" title="3">matches = append(matches, match...)

                        if len(limit.Orders) == 0 </span><span class="cov3" title="2">{
                                limitToDelete = append(limitToDelete, limit)
                        }</span>
                        <span class="cov4" title="3">if order.IsFilled() </span><span class="cov1" title="1">{
                                break</span>
                        }
                }

                <span class="cov1" title="1">for _, limit := range limitToDelete </span><span class="cov3" title="2">{
                        orderBook.clearLimit(true, limit)
                }</span>
        }

        <span class="cov3" title="2">return matches</span>
}

func (ob *OrderBook) Asks() []*Limit <span class="cov1" title="1">{
        sort.Sort(ByBestAsk{ob.asks})
        return ob.asks
}</span>

func (ob *OrderBook) Bids() []*Limit <span class="cov1" title="1">{
        sort.Sort(ByBestBid{ob.bids})
        return ob.bids
}</span>

func (ob *OrderBook) BidTotalVolume() float64 <span class="cov6" title="5">{
        totalVolumne := 0.0
        for _, limit := range ob.bids </span><span class="cov7" title="8">{
                totalVolumne += limit.TotalVolume
        }</span>
        <span class="cov6" title="5">return totalVolumne</span>
}

func (ob *OrderBook) AskTotalVolume() float64 <span class="cov3" title="2">{
        totalVolumne := 0.0
        for _, limit := range ob.asks </span><span class="cov3" title="2">{
                totalVolumne += limit.TotalVolume
        }</span>
        <span class="cov3" title="2">return totalVolumne</span>
}

func (ob *OrderBook) clearLimit(bid bool, limit *Limit) <span class="cov4" title="3">{
        if bid </span><span class="cov4" title="3">{
                delete(ob.BidLimits, limit.Price)
                // remove limit from orderbook.bids
                for i := 0; i &lt; len(ob.bids); i++ </span><span class="cov4" title="3">{
                        if ob.bids[i] == limit </span><span class="cov4" title="3">{
                                // remove the limit from the slice
                                ob.bids = append(ob.bids[:i], ob.bids[i+1:]...)
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                delete(ob.AskLimits, limit.Price)
                // remove limit from orderbook.asks
                for i := 0; i &lt; len(ob.asks); i++ </span><span class="cov0" title="0">{
                        if ob.asks[i] == limit </span><span class="cov0" title="0">{
                                // remove the limit from the slice
                                ob.asks = append(ob.asks[:i], ob.asks[i+1:]...)
                                break</span>
                        }
                }

        }

}

func (ob *OrderBook) CancelOrder(order *Order) <span class="cov1" title="1">{
        limit := order.Limit
        limit.deleteOrder(order)
        if len(limit.Orders) == 0 </span><span class="cov1" title="1">{
                ob.clearLimit(order.Bid, limit)
        }</span>

        <span class="cov1" title="1">delete(ob.limitOrderIdMap, order.ID)</span>
}

func (orderBook *OrderBook) GetOrderById(id int64) *Order <span class="cov0" title="0">{
        return orderBook.limitOrderIdMap[id]
}</span>

func (orderBook *OrderBook) GetLimitOrderIds() []int64 <span class="cov0" title="0">{
        limitOrderIds := make([]int64, 0)
        for k, _ := range orderBook.limitOrderIdMap </span><span class="cov0" title="0">{
                limitOrderIds = append(limitOrderIds, k)
        }</span>
        <span class="cov0" title="0">return limitOrderIds</span>
}

// ------------------------------------------------------------------------

// Limits
type Limits []*Limit

// ByBestAsk
type ByBestAsk struct{ Limits }

func (a ByBestAsk) Len() int           <span class="cov1" title="1">{ return len(a.Limits) }</span>
func (a ByBestAsk) Less(i, j int) bool <span class="cov0" title="0">{ return a.Limits[i].Price &lt; a.Limits[j].Price }</span>
func (a ByBestAsk) Swap(i, j int)      <span class="cov0" title="0">{ a.Limits[i], a.Limits[j] = a.Limits[j], a.Limits[i] }</span>

// ByBestBid
type ByBestBid struct{ Limits }

func (b ByBestBid) Len() int           <span class="cov1" title="1">{ return len(b.Limits) }</span>
func (b ByBestBid) Less(i, j int) bool <span class="cov3" title="2">{ return b.Limits[i].Price &gt; b.Limits[j].Price }</span>
func (b ByBestBid) Swap(i, j int)      <span class="cov0" title="0">{ b.Limits[i], b.Limits[j] = b.Limits[j], b.Limits[i] }</span>

// Orders
type Orders []*Order

func (orders Orders) Len() int <span class="cov5" title="4">{ return len(orders) }</span>
func (orders Orders) Swap(i, j int) <span class="cov0" title="0">{
        (orders)[i], (orders)[j] = (orders)[j], (orders)[i]
}</span>
func (orders Orders) Less(i, j int) bool <span class="cov3" title="2">{
        return orders[i].Timestamp &lt; (orders)[j].Timestamp
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package user

import (
        "crypto/ecdsa"
        "github.com/ethereum/go-ethereum/crypto"
        "math/rand"
)

type User struct {
        UserID     int64
        Username   string
        Address    string
        PrivateKey *ecdsa.PrivateKey
}

func NewUser(username, address, hotWalletPrivateKey string) *User <span class="cov0" title="0">{
        edcdsaPkey, err := crypto.HexToECDSA(hotWalletPrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;User{
                UserID:     int64(rand.Intn(100000000)),
                Username:   username,
                Address:    address,
                PrivateKey: edcdsaPkey,
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package book

import (
        "errors"
        "github.com/emirpasic/gods/maps/treemap"
        "github.com/emirpasic/gods/utils"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/johnny1110/crypto-exchange/engine-v2/util"
)

// BookSide represents one side (bid or ask) of the order book
// internally maintained as an ordered map from price -&gt; deque of orders.
// For ask, highest price has priority; for bid, lowest price.
// The comparison function depends on the side.
type BookSide struct {
        priceLevels      *treemap.Map // key: float64 price, value: *util.Deque (price ordered map)
        isBid            bool         // true = bid side (min-first), false = ask side (max-first)
        totalVolume      float64      // all volume sit in bookSide
        totalQuoteAmount float64      // all size * price
}

func NewBookSide(isBid bool) *BookSide <span class="cov4" title="22">{
        // choose comparator: reverse for buys
        var cmp utils.Comparator
        if isBid </span><span class="cov4" title="11">{
                cmp = utils.Float64Comparator // will treat smaller &lt; larger, but we'll always call Rightmost for buys
        }</span> else<span class="cov4" title="11"> {
                cmp = utils.Float64Comparator // same comparator
        }</span>
        <span class="cov4" title="22">return &amp;BookSide{
                priceLevels:      treemap.NewWith(cmp),
                isBid:            isBid,
                totalVolume:      0,
                totalQuoteAmount: 0,
        }</span>
}

// AddOrderNode inserts a node at a given price level, creating the level if needed.
func (bs *BookSide) AddOrderNode(price float64, node *model.OrderNode) <span class="cov10" title="1079">{
        v, ok := bs.priceLevels.Get(price)
        if !ok </span><span class="cov6" title="81">{
                deque := util.NewOrderNodeDeque()
                bs.priceLevels.Put(price, deque)
                v = deque
        }</span>
        // force convert to type OrderNodeDeque
        <span class="cov10" title="1079">deque := v.(*util.OrderNodeDeque)
        deque.PushBack(node)
        bs.totalVolume += node.Size()
        bs.totalQuoteAmount += node.Size() * node.Price()</span>
}

// RemoveOrderNode removes a specific node from the deque at price.
// If the deque becomes empty, removes the price level.
func (bs *BookSide) RemoveOrderNode(price float64, node *model.OrderNode) error <span class="cov9" title="1003">{
        v, ok := bs.priceLevels.Get(price)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("price level not found")
        }</span>

        <span class="cov9" title="1003">deque := v.(*util.OrderNodeDeque)
        err := deque.Remove(node)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // remove price level if current price level is empty
        <span class="cov9" title="1003">if deque.IsEmpty() </span><span class="cov4" title="14">{
                bs.priceLevels.Remove(price)
        }</span>

        <span class="cov9" title="1003">bs.totalVolume -= node.Size()
        bs.totalQuoteAmount -= node.Size() * node.Price()
        return nil</span>
}

// BestPrice returns the best price on this side (max for buys, min for sells).
func (bs *BookSide) BestPrice() (float64, error) <span class="cov4" title="20">{
        if bs.priceLevels.Empty() </span><span class="cov1" title="1">{
                return 0, errors.New("no price levels sit in book side")
        }</span>

        // Bid is buy side
        <span class="cov4" title="19">if bs.isBid </span><span class="cov3" title="5">{
                // best bid(buy) price is highest price
                k, _ := bs.priceLevels.Max()
                return k.(float64), nil
        }</span> else<span class="cov4" title="14"> {
                // Ask is sell side, best ask(sell) price is lowest price
                k, _ := bs.priceLevels.Min()
                return k.(float64), nil
        }</span>
}

// PeekBest returns the earliest OrderNode at the best price without removing it.
func (bs *BookSide) PeekBest() (*model.OrderNode, error) <span class="cov0" title="0">{
        bestPrice, err := bs.BestPrice()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dq, _ := bs.priceLevels.Get(bestPrice)
        return dq.(*util.OrderNodeDeque).PeekFront(), nil</span>
}

// PopBest removes and returns the earliest OrderNode at the best price.
// Also cleans up the price level if empty.
func (bs *BookSide) PopBest() (*model.OrderNode, error) <span class="cov4" title="11">{
        bestPrice, err := bs.BestPrice()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="11">v, _ := bs.priceLevels.Get(bestPrice)
        deque := v.(*util.OrderNodeDeque)
        node, err := deque.PopFront()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="11">if deque.IsEmpty() </span><span class="cov3" title="10">{
                bs.priceLevels.Remove(bestPrice)
        }</span>

        <span class="cov4" title="11">bs.totalVolume -= node.Size()
        bs.totalQuoteAmount -= node.Size() * node.Price()
        return node, nil</span>
}

// HasPriceLevel checks if a given price level exists.
func (bs *BookSide) HasPriceLevel(price float64) bool <span class="cov0" title="0">{
        _, found := bs.priceLevels.Get(price)
        return found
}</span>

// Len returns number of price levels.
func (bs *BookSide) Len() int <span class="cov3" title="6">{
        return bs.priceLevels.Size()
}</span>

func (bs *BookSide) TotalVolume() float64 <span class="cov5" title="23">{
        return bs.totalVolume
}</span>

func (bs *BookSide) TotalQuoteAmount() float64 <span class="cov4" title="14">{
        return bs.totalQuoteAmount
}</span>

func (bs *BookSide) PutToHead(price float64, node *model.OrderNode) <span class="cov2" title="4">{
        v, ok := bs.priceLevels.Get(price)
        if !ok </span><span class="cov2" title="4">{
                deque := util.NewOrderNodeDeque()
                bs.priceLevels.Put(price, deque)
                v = deque
        }</span>
        // force convert to type OrderNodeDeque
        <span class="cov2" title="4">deque := v.(*util.OrderNodeDeque)
        deque.PushHead(node)
        bs.totalVolume += node.Size()
        bs.totalQuoteAmount += node.Size() * node.Price()</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package book

import (
        "errors"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
)

// indexEntry stores the side, price level, and pointer to the order node for quick lookup.
type indexEntry struct {
        Side  model.Side
        Price float64
        Node  *model.OrderNode
}

// OrderIndex maintains a mapping from order ID to its indexEntry.
type OrderIndex struct {
        index map[string]indexEntry
}

func NewOrderIndex() *OrderIndex <span class="cov3" title="7">{
        return &amp;OrderIndex{index: make(map[string]indexEntry)}
}</span>

// Add inserts a new mapping for the given order ID.
func (oi *OrderIndex) Add(node *model.OrderNode) <span class="cov9" title="1046">{
        order := node.Order
        oi.index[order.ID] = indexEntry{Side: order.Side, Price: order.Price, Node: node}
}</span>

// Remove deletes the mapping for the given order ID.
// Returns an order, error if the order ID is not found.
func (oi *OrderIndex) Remove(orderID string) (*model.Order, error) <span class="cov9" title="1007">{
        entry, found := oi.index[orderID]
        if !found </span><span class="cov0" title="0">{
                return nil, errors.New("order ID not found in index")
        }</span>
        <span class="cov9" title="1007">order := entry.Node.Order
        delete(oi.index, orderID)
        return order, nil</span>
}

// Get retrieves the indexEntry for the given order ID.
// Returns the entry and true if found, or an empty entry and false otherwise.
func (oi *OrderIndex) Get(orderID string) (model.Side, float64, *model.OrderNode, bool) <span class="cov9" title="1002">{
        entry, found := oi.index[orderID]
        if !found </span><span class="cov0" title="0">{
                return 0, 0, nil, false
        }</span>
        <span class="cov9" title="1002">return entry.Side, entry.Price, entry.Node, true</span>
}

func (oi *OrderIndex) OrderIdExist(id string) bool <span class="cov10" title="1056">{
        _, found := oi.index[id]
        return found
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package book

import (
        "errors"
        "fmt"
        "github.com/johnny1110/crypto-exchange/engine-v2/market"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/johnny1110/crypto-exchange/engine-v2/util"
        "github.com/labstack/gommon/log"
        "sync"
        "time"
)

// Errors
var (
        ErrOrderExists          = errors.New("order already exists")
        ErrOrderNotFound        = errors.New("order not found")
        ErrInsufficientVolume   = errors.New("insufficient volume")
        ErrUnsupportedOrderType = errors.New("unsupported order type")
)

// Trade (Match) represents a filled trade between two orders.
type Trade struct {
        Market     string
        BidOrderID string
        AskOrderID string
        BidUserID  string
        AskUserID  string
        BidFeeRate float64 // Bid order fee rate
        AskFeeRate float64 // Ask order fee rate
        Price      float64 // price limit
        Size       float64 // dealt qty
        TradeValue float64 // Price * Size
        Timestamp  time.Time
}

func (t Trade) String() string <span class="cov3" title="8">{
        return fmt.Sprintf(
                "Trade{Market: %q, BidOrderID: %q, AskOrderID: %q, Price: %.8f, Size: %.8f, Value: %.8f, "+
                        "BidFee: %.4f%%, AskFee: %.4f%%, Timestamp: %s}",
                t.Market, t.BidOrderID, t.AskOrderID, t.Price, t.Size, t.TradeValue,
                t.BidFeeRate*100, t.AskFeeRate*100, t.Timestamp.Format(time.RFC3339),
        )
}</span>

// GetOrderIDBySide returns order ID by side
func (t Trade) GetOrderIDBySide(side model.Side) string <span class="cov0" title="0">{
        switch side </span>{
        case model.BID:<span class="cov0" title="0">
                return t.BidOrderID</span>
        case model.ASK:<span class="cov0" title="0">
                return t.AskOrderID</span>
        }
        <span class="cov0" title="0">panic(fmt.Sprintf("invalid side: %v", side))</span>
}

type PriceVolumePair struct {
        Price  float64 `json:"price"`
        Volume float64 `json:"volume"`
}

func NewPriceVolumePair(price float64, volume float64) *PriceVolumePair <span class="cov0" title="0">{
        return &amp;PriceVolumePair{
                Price:  price,
                Volume: volume,
        }
}</span>

// BookSnapshot holds the top 20 bid and ask levels
type BookSnapshot struct {
        // key: priceLevel value: volume
        BidSide      []*PriceVolumePair `json:"bid_side"`
        AskSide      []*PriceVolumePair `json:"ask_side"`
        LatestPrice  float64            `json:"latest_price"`
        BestBidPrice float64            `json:"best_bid_price"`
        BestAskPrice float64            `json:"best_ask_price"`
        TotalBidSize float64            `json:"total_bid_size"`
        TotalAskSize float64            `json:"total_ask_size"`
        Timestamp    time.Time          `json:"-"`
}

func NewBookSnapshot() *BookSnapshot <span class="cov3" title="7">{
        return &amp;BookSnapshot{
                BidSide:   make([]*PriceVolumePair, 0, 20),
                AskSide:   make([]*PriceVolumePair, 0, 20),
                Timestamp: time.Now(),
        }
}</span>

// OrderBook maintains buy and sell sides, and a global index for fast order lookup.
type OrderBook struct {
        market      *market.MarketInfo
        bidSide     *BookSide
        askSide     *BookSide
        orderIndex  *OrderIndex
        latestPrice float64

        snapshot *BookSnapshot // best top 20 price snapshot

        // lock
        obMu       sync.RWMutex // OrderBook RW mutex
        snapshotMu sync.RWMutex // BookSnapshot RW mutex
}

// NewOrderBook creates a new OrderBook instance.
func NewOrderBook(marketInfo *market.MarketInfo) *OrderBook <span class="cov3" title="7">{
        if marketInfo == nil </span><span class="cov0" title="0">{
                panic("market info cannot be nil")</span>
        }
        <span class="cov3" title="7">return &amp;OrderBook{
                market:     marketInfo,
                bidSide:    NewBookSide(true),
                askSide:    NewBookSide(false),
                orderIndex: NewOrderIndex(),
                snapshot:   NewBookSnapshot(),
        }</span>
}

// getSide returns the book side for the given order side
func (ob *OrderBook) getSide(side model.Side) *BookSide <span class="cov10" title="2048">{
        if side == model.BID </span><span class="cov9" title="2024">{
                return ob.bidSide
        }</span>
        <span class="cov4" title="24">return ob.askSide</span>
}

// getOppositeSide returns the opposite book side
func (ob *OrderBook) getOppositeSide(side model.Side) *BookSide <span class="cov3" title="9">{
        if side == model.BID </span><span class="cov3" title="7">{
                return ob.askSide
        }</span>
        <span class="cov1" title="2">return ob.bidSide</span>
}

// Snapshot returns a copy of the current book snapshot
func (ob *OrderBook) Snapshot() BookSnapshot <span class="cov0" title="0">{
        ob.snapshotMu.RLock()
        defer ob.snapshotMu.RUnlock()

        return BookSnapshot{
                BidSide:      ob.copyPriceVolumePairs(ob.snapshot.BidSide),
                AskSide:      ob.copyPriceVolumePairs(ob.snapshot.AskSide),
                BestAskPrice: ob.snapshot.BestAskPrice,
                BestBidPrice: ob.snapshot.BestBidPrice,
                LatestPrice:  ob.snapshot.LatestPrice,
                TotalAskSize: ob.snapshot.TotalAskSize,
                TotalBidSize: ob.snapshot.TotalBidSize,
                Timestamp:    ob.snapshot.Timestamp,
        }
}</span>

// copyPriceVolumePairs creates a deep copy of price-volume pairs
func (ob *OrderBook) copyPriceVolumePairs(pairs []*PriceVolumePair) []*PriceVolumePair <span class="cov0" title="0">{
        if pairs == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">copied := make([]*PriceVolumePair, len(pairs))
        for i, pair := range pairs </span><span class="cov0" title="0">{
                copied[i] = &amp;PriceVolumePair{Price: pair.Price, Volume: pair.Volume}
        }</span>
        <span class="cov0" title="0">return copied</span>
}

// RefreshSnapshot updates the snapshot with current top 20 levels
func (ob *OrderBook) RefreshSnapshot() <span class="cov0" title="0">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()

        ob.snapshotMu.Lock()
        defer ob.snapshotMu.Unlock()

        ob.refreshBidSnapshot()
        ob.refreshAskSnapshot()
        ob.snapshot.LatestPrice = ob.latestPrice
        bestBIdPrice, _ := ob.bidSide.BestPrice()
        bestAskPrice, _ := ob.askSide.BestPrice()
        ob.snapshot.BestBidPrice = bestBIdPrice
        ob.snapshot.BestAskPrice = bestAskPrice
        ob.snapshot.Timestamp = time.Now()
        ob.snapshot.TotalBidSize = ob.bidSide.totalVolume
        ob.snapshot.TotalAskSize = ob.askSide.totalVolume
}</span>

// refreshBidSnapshot refreshes bid side snapshot (top 20 highest prices)
func (ob *OrderBook) refreshBidSnapshot() <span class="cov0" title="0">{
        ob.snapshot.BidSide = ob.snapshot.BidSide[:0] // Reset slice

        it := ob.bidSide.priceLevels.Iterator()
        it.End() // Start from highest price

        count := 0
        for it.Prev() &amp;&amp; count &lt; 20 </span><span class="cov0" title="0">{
                price := it.Key().(float64)
                deque := it.Value().(*util.OrderNodeDeque)
                volume := deque.Volume()

                ob.snapshot.BidSide = append(ob.snapshot.BidSide,
                        NewPriceVolumePair(price, volume))
                count++
        }</span>
}

// refreshAskSnapshot refreshes ask side snapshot (top 20 lowest prices)
func (ob *OrderBook) refreshAskSnapshot() <span class="cov0" title="0">{
        ob.snapshot.AskSide = ob.snapshot.AskSide[:0] // Reset slice

        it := ob.askSide.priceLevels.Iterator()
        it.Begin() // Start from lowest price

        count := 0
        for it.Next() &amp;&amp; count &lt; 20 </span><span class="cov0" title="0">{
                price := it.Key().(float64)
                deque := it.Value().(*util.OrderNodeDeque)
                volume := deque.Volume()

                ob.snapshot.AskSide = append(ob.snapshot.AskSide,
                        NewPriceVolumePair(price, volume))
                count++
        }</span>
}

// Order Section &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

// CancelOrder removes an existing order from the book by its ID.
func (ob *OrderBook) CancelOrder(orderID string) (*model.Order, error) <span class="cov9" title="1002">{
        ob.obMu.Lock()
        defer ob.obMu.Unlock()

        // Lookup index
        side, price, node, found := ob.orderIndex.Get(orderID)
        if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", ErrOrderNotFound, orderID)
        }</span>

        // Remove from appropriate book side
        <span class="cov9" title="1002">bookSide := ob.getSide(side)
        if err := bookSide.RemoveOrderNode(price, node); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to remove order from book side: %w", err)
        }</span>

        // Remove from index
        <span class="cov9" title="1002">return ob.removeOrderIndex(orderID)</span>
}

// PlaceOrder place order into order book, support LIMIT/MAKER, LIMIT/TAKER and MARKET 3 kind of scenario
func (ob *OrderBook) PlaceOrder(orderType model.OrderType, order *model.Order) ([]Trade, error) <span class="cov9" title="1056">{
        if order == nil </span><span class="cov0" title="0">{
                return nil, errors.New("order cannot be nil")
        }</span>

        <span class="cov9" title="1056">ob.obMu.Lock()
        defer ob.obMu.Unlock()

        // Check if order ID already exists
        if ob.orderIndex.OrderIdExist(order.ID) </span><span class="cov2" title="4">{
                return nil, fmt.Errorf("%w: %s", ErrOrderExists, order.ID)
        }</span>

        <span class="cov9" title="1052">log.Debugf("[OrderBook] PlaceOrder %s order, orderID: %s, side: %s", orderType, order.ID, order.Side)

        switch orderType </span>{
        case model.LIMIT:<span class="cov9" title="1048">
                return ob.placeLimitOrder(order)</span>
        case model.MARKET:<span class="cov2" title="4">
                return ob.placeMarketOrder(order)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("%w: %v", ErrUnsupportedOrderType, orderType)</span>
        }
}

// placeLimitOrder handles limit order placement
func (ob *OrderBook) placeLimitOrder(order *model.Order) ([]Trade, error) <span class="cov9" title="1048">{
        if order.Mode == model.MAKER </span><span class="cov9" title="1043">{
                // Maker order: add to book without matching
                err := ob.makeLimitOrder(order)
                return nil, err
        }</span>

        // Taker order: try to match first, then add remainder to book
        <span class="cov2" title="5">trades, err := ob.takeLimitOrder(order)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="5">ob.updateLatestPrice(trades)
        return trades, nil</span>
}

// placeMarketOrder handles market order placement
func (ob *OrderBook) placeMarketOrder(order *model.Order) ([]Trade, error) <span class="cov2" title="4">{
        var trades []Trade
        var err error

        switch order.Side </span>{
        case model.BID:<span class="cov1" title="2">
                trades, err = ob.takeMarketBidOrder(order)</span>
        case model.ASK:<span class="cov1" title="2">
                trades, err = ob.takeMarketAskOrder(order)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid order side: %v", order.Side)</span>
        }

        <span class="cov2" title="4">if err != nil </span><span class="cov1" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="2">ob.updateLatestPrice(trades)
        return trades, nil</span>
}

// MakeLimitOrder adds a new limit order to the book without attempting to match. (Maker)
func (ob *OrderBook) makeLimitOrder(order *model.Order) error <span class="cov9" title="1046">{
        node := &amp;model.OrderNode{Order: order}

        // Add to appropriate side
        side := ob.getSide(order.Side)
        side.AddOrderNode(order.Price, node)
        // Add to index for fast lookup/cancel
        ob.addOrderIndex(node)

        return nil
}</span>

// takeLimitOrder matches a limit order against the book (Taker).
// Attempts to match an incoming order against the book and returns the resulting trades.
// Any unfilled portion of the incoming order will be added to the book.
func (ob *OrderBook) takeLimitOrder(order *model.Order) ([]Trade, error) <span class="cov2" title="5">{
        var trades []Trade
        opposite := ob.getOppositeSide(order.Side)

        // Keep matching until order is filled or no more matches possible
        for order.RemainingSize &gt; 0 </span><span class="cov3" title="7">{
                bestPrice, err := opposite.BestPrice()
                if err != nil || !ob.canMatch(order.Side, order.Price, bestPrice) </span><span class="cov2" title="3">{
                        break</span> // no more order or hit stop limit, just break
                }

                <span class="cov2" title="4">trade, shouldContinue, err := ob.executeMatch(order, opposite, bestPrice)
                if err != nil </span><span class="cov0" title="0">{
                        return trades, err
                }</span>
                <span class="cov2" title="4">trades = append(trades, trade)

                if !shouldContinue </span><span class="cov0" title="0">{
                        break</span>
                }

        }

        // Add remaining quantity to book if any
        <span class="cov2" title="5">if order.RemainingSize &gt; 0 </span><span class="cov2" title="3">{
                if err := ob.makeLimitOrder(order); err != nil </span><span class="cov0" title="0">{
                        return trades, err
                }</span>
        }

        <span class="cov2" title="5">return trades, nil</span>
}

// Market Order Logic Section &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
func (ob *OrderBook) takeMarketAskOrder(order *model.Order) (trades []Trade, err error) <span class="cov1" title="2">{
        opposite := ob.getOppositeSide(order.Side)

        // Check if there's enough volume
        if opposite.totalVolume &lt; order.RemainingSize </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%w for market ask order in %s", ErrInsufficientVolume, ob.market.Name)
        }</span>

        // loop until order fulfilled or break by stop limit
        <span class="cov1" title="1">for order.RemainingSize &gt; 0 </span><span class="cov2" title="3">{
                bestNode, err := opposite.PopBest()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("[OrderBook] critical error in market ask order %s: %v", order.ID, err)
                        break</span>
                }

                // Determine trade qty
                <span class="cov2" title="3">tradeQty := min(order.RemainingSize, bestNode.Order.RemainingSize)
                trade := ob.createTrade(order, bestNode.Order, bestNode.Order.Price, tradeQty)
                trades = append(trades, trade)

                // Update qty
                bestNode.Order.RemainingSize -= tradeQty
                order.RemainingSize -= tradeQty

                // Handle counter-party
                if bestNode.Order.RemainingSize &gt; 0 </span><span class="cov1" title="1">{
                        opposite.PutToHead(bestNode.Order.Price, bestNode)
                }</span> else<span class="cov1" title="2"> {
                        if _, err := ob.orderIndex.Remove(bestNode.Order.ID); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("[OrderBook] failed to remove order from index: %s", bestNode.Order.ID)
                        }</span>
                }

        }

        <span class="cov1" title="1">return trades, err</span>
}

func (ob *OrderBook) takeMarketBidOrder(order *model.Order) (trades []Trade, err error) <span class="cov1" title="2">{
        opposite := ob.getOppositeSide(order.Side)

        // Check if there's enough quote amount
        if opposite.totalQuoteAmount &lt; order.QuoteAmount </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%w for market bid order in %s",
                        ErrInsufficientVolume, ob.market.Name)
        }</span>

        <span class="cov1" title="1">remainingQuoteAmt := order.QuoteAmount

        // Consume all remainingQuoteAmt
        for remainingQuoteAmt &gt; 0 </span><span class="cov1" title="2">{
                bestNode, err := opposite.PopBest()
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("[OrderBook] critical error in market bid order %s: %v", order.ID, err)
                        break</span>
                }

                <span class="cov1" title="2">oppositeOrder := bestNode.Order
                oppositeOrderQuoteAmt := oppositeOrder.RemainingSize * oppositeOrder.Price

                // Determine trade qty
                var tradeQty float64
                if remainingQuoteAmt &gt;= oppositeOrderQuoteAmt </span><span class="cov1" title="1">{
                        // eat all oppositeOrder qty
                        tradeQty = oppositeOrder.RemainingSize
                }</span> else<span class="cov1" title="1"> {
                        tradeQty = remainingQuoteAmt / oppositeOrder.Price
                }</span>

                <span class="cov1" title="2">trade := ob.createTrade(order, oppositeOrder, oppositeOrder.Price, tradeQty)
                trades = append(trades, trade)

                // Update qty
                oppositeOrder.RemainingSize -= tradeQty
                remainingQuoteAmt -= tradeQty * oppositeOrder.Price
                order.OriginalSize += tradeQty // increase eaten order's OriginalSize

                // If counter-party still has leftover, put it back into book side (price level head)
                if oppositeOrder.RemainingSize &gt; 0 </span><span class="cov1" title="1">{
                        opposite.PutToHead(oppositeOrder.Price, bestNode)
                }</span> else<span class="cov1" title="1"> {
                        // If counter-party has no leftover, remove it from orderIndex
                        if _, err := ob.removeOrderIndex(oppositeOrder.ID); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("[OrderBook] failed to remove order from index: %s", oppositeOrder.ID)
                        }</span>
                }
        }

        <span class="cov1" title="1">return trades, err</span>
}

// Market Order Logic Section &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

func (ob *OrderBook) TotalAskVolume() float64 <span class="cov3" title="10">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        return ob.askSide.TotalVolume()
}</span>

func (ob *OrderBook) TotalAskQuoteAmount() float64 <span class="cov3" title="6">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        return ob.askSide.TotalQuoteAmount()
}</span>

func (ob *OrderBook) TotalBidVolume() float64 <span class="cov3" title="12">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        return ob.bidSide.TotalVolume()
}</span>

func (ob *OrderBook) TotalBidQuoteAmount() float64 <span class="cov3" title="7">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        return ob.bidSide.TotalQuoteAmount()
}</span>

func (ob *OrderBook) LatestPrice() float64 <span class="cov1" title="2">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        return ob.latestPrice
}</span>

func (ob *OrderBook) updateLatestPrice(trades []Trade) <span class="cov3" title="7">{
        if len(trades) == 0 </span><span class="cov1" title="2">{
                return
        }</span>
        <span class="cov2" title="5">lastTrade := trades[len(trades)-1]
        ob.latestPrice = lastTrade.Price</span>
}

func (ob *OrderBook) removeOrderIndex(orderId string) (*model.Order, error) <span class="cov9" title="1003">{
        return ob.orderIndex.Remove(orderId)
}</span>

func (ob *OrderBook) addOrderIndex(node *model.OrderNode) <span class="cov9" title="1046">{
        ob.orderIndex.Add(node)
}</span>

func (ob *OrderBook) BestBid() (float64, float64, error) <span class="cov0" title="0">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()
        bestPrice, err := ob.bidSide.BestPrice()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">volume := ob.bidSide.TotalVolume()
        return bestPrice, volume, nil</span>
}

func (ob *OrderBook) BestAsk() (float64, float64, error) <span class="cov0" title="0">{
        ob.obMu.RLock()
        defer ob.obMu.RUnlock()

        bestPrice, err := ob.askSide.BestPrice()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">volume := ob.askSide.TotalVolume()
        return bestPrice, volume, nil</span>
}

func (ob *OrderBook) MarketInfo() *market.MarketInfo <span class="cov0" title="0">{
        return ob.market
}</span>

func (ob *OrderBook) GetAssets() (string, string) <span class="cov0" title="0">{
        return ob.market.BaseAsset, ob.market.QuoteAsset
}</span>

// canMatch checks if an order can match at the given price
func (ob *OrderBook) canMatch(orderSide model.Side, orderPrice, bestPrice float64) bool <span class="cov3" title="6">{
        if orderSide == model.BID </span><span class="cov3" title="6">{
                return orderPrice &gt;= bestPrice
        }</span>
        <span class="cov0" title="0">return orderPrice &lt;= bestPrice</span>
}

// executeMatch executes a single match between orders
func (ob *OrderBook) executeMatch(order *model.Order, opposite *BookSide, bestPrice float64) (Trade, bool, error) <span class="cov2" title="4">{
        bestNode, err := opposite.PopBest()
        if err != nil </span><span class="cov0" title="0">{
                return Trade{}, false, err
        }</span>

        // Calculate trade quantity
        <span class="cov2" title="4">tradeQty := min(order.RemainingSize, bestNode.Order.RemainingSize)

        // Create trade
        trade := ob.createTrade(order, bestNode.Order, bestPrice, tradeQty)

        // Update remaining quantities
        bestNode.Order.RemainingSize -= tradeQty
        order.RemainingSize -= tradeQty

        // Handle counter-party order
        if bestNode.Order.RemainingSize &gt; 0 </span><span class="cov1" title="2">{
                // Put back to front of price level
                opposite.PutToHead(bestPrice, bestNode)
        }</span> else<span class="cov1" title="2"> {
                // Remove from index
                if _, err := ob.orderIndex.Remove(bestNode.Order.ID); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("[OrderBook] failed to remove order from index: %s", bestNode.Order.ID)
                }</span>
        }

        <span class="cov2" title="4">return trade, true, nil</span>
}

// createTrade creates a trade record
func (ob *OrderBook) createTrade(order1, order2 *model.Order, price, size float64) Trade <span class="cov3" title="9">{
        bidOrder, askOrder := ob.determineTradeOrders(order1, order2)

        return Trade{
                Market:     ob.market.Name,
                BidOrderID: bidOrder.ID,
                AskOrderID: askOrder.ID,
                BidUserID:  bidOrder.UserID,
                AskUserID:  askOrder.UserID,
                BidFeeRate: bidOrder.FeeRate,
                AskFeeRate: askOrder.FeeRate,
                Price:      price,
                Size:       size,
                Timestamp:  time.Now(),
        }
}</span>

// determineTradeOrders determines bid/ask order IDs and user IDs
func (ob *OrderBook) determineTradeOrders(order1, order2 *model.Order) (bidOrder *model.Order, askOrder *model.Order) <span class="cov3" title="9">{
        if order1.Side == model.BID </span><span class="cov3" title="6">{
                return order1, order2
        }</span>
        <span class="cov2" title="3">return order2, order1</span>
}

// PutOrder put order into OrderBook directly
func (ob *OrderBook) PutOrder(order *model.Order) error <span class="cov0" title="0">{
        ob.obMu.Lock()
        defer ob.obMu.Unlock()

        err := ob.makeLimitOrder(order)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ob *OrderBook) UpdateLatestPrice(price float64) <span class="cov0" title="0">{
        ob.obMu.Lock()
        defer ob.obMu.Unlock()

        ob.latestPrice = price
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package core

import (
        "errors"
        "fmt"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/engine-v2/market"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/labstack/gommon/log"
        "sync"
        "time"
)

type MatchingEngine struct {
        mu         sync.RWMutex
        orderbooks map[string]*book.OrderBook
}

func NewMatchingEngine(markets []*market.MarketInfo) (*MatchingEngine, error) <span class="cov0" title="0">{
        if len(markets) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("market must have at least one market")
        }</span>
        <span class="cov0" title="0">e := &amp;MatchingEngine{
                orderbooks: make(map[string]*book.OrderBook, len(markets)),
        }
        for _, m := range markets </span><span class="cov0" title="0">{
                e.orderbooks[m.Name] = book.NewOrderBook(m)
        }</span>
        <span class="cov0" title="0">return e, nil</span>
}

func (e *MatchingEngine) GetOrderBook(market string) (*book.OrderBook, error) <span class="cov0" title="0">{
        ob, ok := e.orderbooks[market]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("market %s not found", market)
        }</span>
        <span class="cov0" title="0">return ob, nil</span>
}

func (e *MatchingEngine) ValidateMarket(market string) bool <span class="cov0" title="0">{
        _, ok := e.orderbooks[market]
        return ok
}</span>

func (e *MatchingEngine) Markets() []string <span class="cov0" title="0">{
        markets := make([]string, 0, len(e.orderbooks))
        for m := range e.orderbooks </span><span class="cov0" title="0">{
                markets = append(markets, m)
        }</span>
        <span class="cov0" title="0">return markets</span>
}

func (e *MatchingEngine) PlaceOrder(market string, orderType model.OrderType, order *model.Order) ([]book.Trade, error) <span class="cov0" title="0">{
        ob, err := e.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("[Engine] PlaceOrder, market: [%s], type:[%v], mode:[%v], side:[%v] orderId:[%s], prize:[%v], size:[%v], quoteAmt:[%v], feeRate:[%.4f]%",
                market, orderType, order.Mode, order.Side, order.ID, order.Price, order.RemainingSize, order.QuoteAmount, order.FeeRate*100)

        return ob.PlaceOrder(orderType, order)</span>
}

func (e *MatchingEngine) CancelOrder(market string, orderID string) (*model.Order, error) <span class="cov0" title="0">{
        ob, err := e.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Infof("[Engine] CancelOrder, market:[%s], orderID:[%s]", market, orderID)
        return ob.CancelOrder(orderID)</span>
}

func (e *MatchingEngine) Snapshot(market string) (bidPrice, bidSize, askPrice, askSize float64, err error) <span class="cov0" title="0">{
        ob, err := e.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">bidPrice, bidSize, _ = ob.BestBid()
        askPrice, askSize, _ = ob.BestAsk()
        return</span>
}

func (e *MatchingEngine) StartSnapshotRefresher() <span class="cov0" title="0">{

        ticker := time.NewTicker(300 * time.Millisecond)

        go func() </span><span class="cov0" title="0">{
                for range ticker.C </span><span class="cov0" title="0">{
                        for _, market := range e.Markets() </span><span class="cov0" title="0">{
                                ob, err := e.GetOrderBook(market)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("[Engine] StartSnapshotRefresher: GetOrderBook err: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        ob.RefreshSnapshot()
                                }</span>
                        }
                }
        }()
}

func (e *MatchingEngine) RecoverOrderBook(market string, orders []*model.Order, latestPrice float64) error <span class="cov0" title="0">{
        if market == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("marketInfo is nil")
        }</span>
        <span class="cov0" title="0">ob, err := e.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Infof("[Engine] RecoverOrderBook, market: [%s], order count: %v", market, len(orders))
        for _, order := range orders </span><span class="cov0" title="0">{
                err := ob.PutOrder(order)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("[Engine] RecoverOrderBook failed to record orderId: [%s], error:%v", order.ID, err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">ob.UpdateLatestPrice(latestPrice)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package market

import (
        "fmt"
)

type MarketInfo struct {
        Name       string // e.g."BTC/USDT"
        BaseAsset  string // e.g. "BTC"
        QuoteAsset string // e.g. "USDT"
}

func NewMarketInfo(name string, baseAsset, quoteAsset string) *MarketInfo <span class="cov10" title="7">{
        return &amp;MarketInfo{
                Name:       name,
                BaseAsset:  baseAsset,
                QuoteAsset: quoteAsset,
        }
}</span>

type MarketManager struct {
        markets map[string]*MarketInfo
}

func NewManager(mkList []MarketInfo) *MarketManager <span class="cov0" title="0">{
        mgr := &amp;MarketManager{
                markets: make(map[string]*MarketInfo),
        }
        for _, mi := range mkList </span><span class="cov0" title="0">{
                mgr.markets[mi.Name] = &amp;mi
        }</span>
        <span class="cov0" title="0">return mgr</span>
}

// List returns the names of all registered market
func (mgr *MarketManager) List() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(mgr.markets))
        for name := range mgr.markets </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// Get retrieves MarketInfo by market name
func (mgr *MarketManager) Get(market string) (*MarketInfo, error) <span class="cov0" title="0">{
        if mi, ok := mgr.markets[market]; ok </span><span class="cov0" title="0">{
                return mi, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("market %s not found", market)</span>
}

// GetAssets input market and return (base, quote) assets.html
func (mgr *MarketManager) GetAssets(market string) (string, string, error) <span class="cov0" title="0">{
        mi, err := mgr.Get(market)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">return mi.BaseAsset, mi.QuoteAsset, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package model

import (
        "time"
)

type Side int
type Mode int
type OrderType int
type OrderStatus string

const (
        LIMIT OrderType = iota
        MARKET
)

const (
        BID Side = iota
        ASK
)

const (
        MAKER Mode = iota
        TAKER
)

const (
        // ORDER_STATUS_NEW indicates an order that has just been created and not yet matched.
        ORDER_STATUS_NEW OrderStatus = "NEW"

        // ORDER_STATUS_PARTIAL indicates an order that has been partially filled.
        ORDER_STATUS_PARTIAL OrderStatus = "PARTIAL"

        // ORDER_STATUS_FILLED indicates an order that has been completely filled.
        ORDER_STATUS_FILLED OrderStatus = "FILLED"

        // ORDER_STATUS_CANCELED indicates an order that has been canceled.
        ORDER_STATUS_CANCELED OrderStatus = "CANCELED"
)

func (ot OrderType) String() string <span class="cov0" title="0">{
        switch ot </span>{
        case LIMIT:<span class="cov0" title="0">
                return "LIMIT"</span>
        case MARKET:<span class="cov0" title="0">
                return "MARKET"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

func (si Side) String() string <span class="cov1" title="1">{
        switch si </span>{
        case BID:<span class="cov1" title="1">
                return "BID"</span>
        case ASK:<span class="cov0" title="0">
                return "ASK"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

func (mo Mode) String() string <span class="cov1" title="1">{
        switch mo </span>{
        case MAKER:<span class="cov0" title="0">
                return "MAKER"</span>
        case TAKER:<span class="cov1" title="1">
                return "TAKER"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

type Order struct {
        ID            string
        UserID        string
        Side          Side
        Price         float64
        OriginalSize  float64
        RemainingSize float64
        QuoteAmount   float64 // only market bid order
        Mode          Mode
        FeeRate       float64
        Timestamp     time.Time
}

func (o *Order) GetStatus() OrderStatus <span class="cov0" title="0">{
        if o.OriginalSize == o.RemainingSize </span><span class="cov0" title="0">{
                return ORDER_STATUS_NEW
        }</span>
        <span class="cov0" title="0">if o.RemainingSize &gt; 0 &amp;&amp; o.RemainingSize &lt; o.OriginalSize </span><span class="cov0" title="0">{
                return ORDER_STATUS_PARTIAL
        }</span>
        <span class="cov0" title="0">if o.RemainingSize == 0 </span><span class="cov0" title="0">{
                return ORDER_STATUS_FILLED
        }</span>
        <span class="cov0" title="0">return ORDER_STATUS_CANCELED</span>
}

func (o *Order) CounterSide() Side <span class="cov0" title="0">{
        return o.Side ^ 1
}</span>

// NewOrder
// side: BID ASK
// mode: MAKER TAKER
func NewOrder(orderId, userId string, side Side, price float64, size float64, quoteAmt float64, mode Mode, feeRate float64) *Order <span class="cov8" title="1087">{
        return &amp;Order{
                ID:            orderId,
                UserID:        userId,
                Side:          side,
                Price:         price,
                OriginalSize:  size,
                RemainingSize: size,
                QuoteAmount:   quoteAmt,
                FeeRate:       feeRate,
                Mode:          mode,
                Timestamp:     time.Now(),
        }
}</span>

type OrderNode struct {
        Order      *Order
        Prev, Next *OrderNode
}

func NewOrderNode(orderId, userId string, side Side, price float64, size float64, quoteAmt float64, orderType Mode, feeRate float64) *OrderNode <span class="cov4" title="33">{
        order := NewOrder(orderId, userId, side, price, size, quoteAmt, orderType, feeRate)
        return &amp;OrderNode{
                Order: order,
        }
}</span>

func (node *OrderNode) Size() float64 <span class="cov10" title="6293">{
        return node.Order.RemainingSize
}</span>

func (node *OrderNode) Price() float64 <span class="cov8" title="2099">{
        return node.Order.Price
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package util

import (
        "errors"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
)

// OrderNodeDeque is a double end queue implement with double linked list.
// It's holds pointers of OrderNode defined in entity pkg.
// User must create OrderNode via model.OrderNode and push them into OrderNodeDeque.
type OrderNodeDeque struct {
        head, tail *model.OrderNode
        size       int
        volume     float64
}

func NewOrderNodeDeque() *OrderNodeDeque <span class="cov6" title="85">{
        return &amp;OrderNodeDeque{
                size:   0,
                volume: 0,
        }
}</span>

// PushBack adds a node to the end of the deque in O(1) time.
func (dq *OrderNodeDeque) PushBack(node *model.OrderNode) <span class="cov10" title="1079">{
        if dq.tail == nil </span><span class="cov6" title="81">{
                dq.head = node
                dq.tail = node
        }</span> else<span class="cov9" title="998"> {
                node.Next = nil
                node.Prev = dq.tail
                dq.tail.Next = node
                dq.tail = node
        }</span>
        <span class="cov10" title="1079">dq.size++
        dq.volume += node.Size()</span>
}

// PushHead adds a node to the head of the deque in O(1) time.
func (dq *OrderNodeDeque) PushHead(node *model.OrderNode) <span class="cov2" title="4">{
        if dq.head == nil </span><span class="cov2" title="4">{
                dq.head = node
                dq.tail = node
        }</span> else<span class="cov0" title="0"> {
                node.Prev = nil
                node.Next = dq.head
                dq.head.Prev = node
                dq.head = node
        }</span>
        <span class="cov2" title="4">dq.size++
        dq.volume += node.Size()</span>
}

// PopFront removes and returns the node at the front of the deque in O(1) time.
// Returns nil and an error if the deque is empty.
func (dq *OrderNodeDeque) PopFront() (*model.OrderNode, error) <span class="cov9" title="794">{
        if dq.head == nil </span><span class="cov0" title="0">{
                return nil, errors.New("OrderNodeDeque is empty")
        }</span>
        <span class="cov9" title="794">node := dq.head

        if dq.size == 1 </span><span class="cov5" title="24">{
                dq.head = nil
                dq.tail = nil
        }</span> else<span class="cov9" title="770"> {
                dq.head = dq.head.Next
                dq.head.Prev = nil
        }</span>
        <span class="cov9" title="794">dq.size--
        dq.volume -= node.Size()

        // clean up the popped node.
        node.Next = nil
        node.Prev = nil // should be nil already, but do it again for safety.
        return node, nil</span>
}

// PeekFront returns the node at the front without removing it.
// Returns nil if the deque is empty.
func (dq *OrderNodeDeque) PeekFront() *model.OrderNode <span class="cov0" title="0">{
        return dq.head
}</span>

// Remove removes a specific node from the deque in O(1) time.
// Returns an error if the node is nil or deque is empty.
func (dq *OrderNodeDeque) Remove(node *model.OrderNode) error <span class="cov9" title="1003">{
        if node == nil </span><span class="cov0" title="0">{
                return errors.New("input node is nil")
        }</span>
        <span class="cov9" title="1003">if dq.size == 0 </span><span class="cov0" title="0">{
                return errors.New("OrderNodeDeque is empty")
        }</span>

        // If node is head
        <span class="cov9" title="1003">if dq.head == node </span><span class="cov9" title="783">{
                _, err := dq.PopFront()
                return err
        }</span>

        // if node is tail
        <span class="cov7" title="220">if dq.tail == node </span><span class="cov6" title="58">{
                dq.tail = node.Prev
                dq.tail.Next = nil
                node.Prev = nil
                dq.size--
                dq.volume -= node.Size()
                return nil
        }</span>

        // Node is in middle
        <span class="cov7" title="162">node.Prev.Next = node.Next
        node.Next.Prev = node.Prev
        node.Next = nil
        node.Prev = nil
        dq.size--
        dq.volume -= node.Size()
        return nil</span>
}

// IsEmpty returns true if the deque has no elements.
func (d *OrderNodeDeque) IsEmpty() bool <span class="cov9" title="1014">{
        return d.size == 0
}</span>

// Size returns the number of elements in the deque.
func (d *OrderNodeDeque) Size() int <span class="cov0" title="0">{
        return d.size
}</span>

// Volume returns the number of elements in the deque.
func (d *OrderNodeDeque) Volume() float64 <span class="cov0" title="0">{
        return d.volume
}</span>

// QuoteAmount returns the quoteAmt(price * allVolume).
func (d *OrderNodeDeque) QuoteAmount() float64 <span class="cov0" title="0">{
        node := d.PeekFront()
        if node == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return node.Price() * d.volume</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "github.com/johnny1110/crypto-exchange/container"
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
)

func main() <span class="cov0" title="0">{
        err := initLogger("logs", log.INFO)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">db, err := initDB(false)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to open database: %v", err)
        }</span>

        <span class="cov0" title="0">engine, err := core.NewMatchingEngine(settings.ALL_MARKETS)

        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to init matching-engine: %v", err)
        }</span>

        <span class="cov0" title="0">c := container.NewContainer(db, engine)
        defer c.Cleanup()

        router := setupRouter(c)

        // Recover OrderBook from db data.
        err = recoverOrderBook(c)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to recover orderbook: %v", err)
        }</span>
        // It will iterate all the market, and do refresh the OrderBook snapshot
        //engine.StartSnapshotRefresher()

        <span class="cov0" title="0">startUpAllScheduler(c)

        // TODO: remove this after testing
        //err = c.AdminService.TestAutoMakeMarket(context.Background())
        //if err != nil {
        //        panic("failed to TestAutoMakeMarket")
        //}

        log.Infof("Exchange Server starting on :8080")
        if err := router.Run(":8080"); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to start server:", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "errors"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/controller"
        "github.com/johnny1110/crypto-exchange/security"
        "github.com/labstack/gommon/log"
        "net/http"
        "strings"
)

// CORS middleware
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return cors.New(cors.Config{
                AllowAllOrigins:  true, // allow all
                AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"},
                AllowHeaders:     []string{"Origin", "Content-Length", "Content-Type", "Authorization", "Admin-Token"},
                AllowWebSockets:  true,
                AllowCredentials: true,
        })
}</span>

// ErrorHandler middleware
func ErrorHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last()
                        switch err.Type </span>{
                        case gin.ErrorTypePublic:<span class="cov0" title="0">
                                c.JSON(c.Writer.Status(), controller.HandleCodeError(controller.BAD_REQUEST, err))</span>
                        case gin.ErrorTypeBind:<span class="cov0" title="0">
                                c.JSON(http.StatusBadRequest, controller.HandleCodeError(controller.BAD_REQUEST, err))</span>
                        default:<span class="cov0" title="0">
                                c.JSON(http.StatusInternalServerError, controller.HandleCodeError(controller.SYSTEM_ERROR, err))</span>
                        }
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// AuthMiddleware middleware
func AuthMiddleware(credentialCache *security.CredentialCache) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        //Authorization header required
                        c.JSON(http.StatusInternalServerError, controller.HandleCodeError(controller.ACCESS_DENIED, errors.New("authorization header required")))
                        c.Abort()
                        return
                }</span>

                // support Bearer token
                <span class="cov0" title="0">token := authHeader
                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        token = strings.TrimPrefix(authHeader, "Bearer ")
                }</span>

                <span class="cov0" title="0">user, err := credentialCache.Get(token)
                if err != nil || user == nil </span><span class="cov0" title="0">{
                        // Invalid or expired token
                        c.JSON(http.StatusUnauthorized, controller.HandleCodeError(controller.ACCESS_DENIED, errors.New("invalid or expired token")))
                        c.Abort()
                        return
                }</span>

                // store user info and token into context
                <span class="cov0" title="0">c.Set("user", user)
                c.Set("userId", user.ID)
                c.Set("username", user.Username)
                c.Set("token", token)

                log.Infof("Logged in user: %s", user.Username)

                c.Next()</span>
        }
}

// AdminMiddleware middleware
func AdminMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                adminToken := c.GetHeader("Admin-Token")
                if adminToken == "" </span><span class="cov0" title="0">{
                        //Authorization header required
                        c.JSON(http.StatusInternalServerError, controller.HandleCodeError(controller.ACCESS_DENIED, errors.New("authorization header required")))
                        c.Abort()
                        return
                }</span>

                // TODO: revamp this, make it better.
                <span class="cov0" title="0">if adminToken != "frizo" </span><span class="cov0" title="0">{
                        // Invalid or expired token
                        c.JSON(http.StatusUnauthorized, controller.HandleCodeError(controller.ACCESS_DENIED, errors.New("invalid or expired token")))
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RateLimitMiddleware middleware
func RateLimitMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                // TODO: IP check
                c.Next()
        }</span>)
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repositoryImpl

import (
        "context"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/repository"
        "strings"
)

type balanceRepository struct {
}

func NewBalanceRepository() repository.IBalanceRepository <span class="cov0" title="0">{
        return &amp;balanceRepository{}
}</span>

// GetBalancesByUserId get balance by userId
func (b balanceRepository) GetBalancesByUserId(ctx context.Context, db repository.DBExecutor, userId string) ([]*dto.Balance, error) <span class="cov0" title="0">{
        query := `SELECT asset, available, locked FROM balances WHERE user_id = ?`

        rows, err := db.QueryContext(ctx, query, userId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query balances: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var balances []*dto.Balance
        for rows.Next() </span><span class="cov0" title="0">{
                balance := &amp;dto.Balance{}
                err := rows.Scan(&amp;balance.Asset, &amp;balance.Available, &amp;balance.Locked)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan balance: %w", err)
                }</span>
                <span class="cov0" title="0">balance.Total = balance.Available + balance.Locked
                balances = append(balances, balance)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("row iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return balances, nil</span>

}

// ModifyAvailableByUserIdAndAsset modify asset balance available amount if sign==true (+), sign==false (-), if available not enough return error.
func (b balanceRepository) ModifyAvailableByUserIdAndAsset(ctx context.Context, db repository.DBExecutor, userID, asset string, sign bool, amount float64) error <span class="cov0" title="0">{
        if sign </span><span class="cov0" title="0">{
                // add available amt.
                query := `UPDATE balances SET available = available + ? WHERE user_id = ? AND asset = ?`
                result, err := db.ExecContext(ctx, query, amount, userID, asset)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to increase available balance: %w", err)
                }</span>

                <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get rows affected: %w", err)
                }</span>

                <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("balance not found for user %s and asset %s", userID, asset)
                }</span>
        } else<span class="cov0" title="0"> {
                // decrease available
                query := `UPDATE balances SET available = available - ? WHERE user_id = ? AND asset = ? AND available &gt;= ?`
                result, err := db.ExecContext(ctx, query, amount, userID, asset, amount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrease available balance: %w", err)
                }</span>

                <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get rows affected: %w", err)
                }</span>

                <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("insufficient available balance or balance not found for user %s and asset %s", userID, asset)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ModifyLockedByUserIdAndAsset modify asset balance locked amount if sign==true (+), sign==false (-), if locked not enough return error.
func (b balanceRepository) ModifyLockedByUserIdAndAsset(ctx context.Context, db repository.DBExecutor, userID, asset string, sign bool, amount float64) error <span class="cov0" title="0">{
        if sign </span><span class="cov0" title="0">{
                query := `UPDATE balances SET locked = locked + ? WHERE user_id = ? AND asset = ?`
                result, err := db.ExecContext(ctx, query, amount, userID, asset)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to increase locked balance: %w", err)
                }</span>

                <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get rows affected: %w", err)
                }</span>

                <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("balance not found for user %s and asset %s", userID, asset)
                }</span>
        } else<span class="cov0" title="0"> {
                query := `UPDATE balances SET locked = locked - ? WHERE user_id = ? AND asset = ? AND locked &gt;= ?`
                result, err := db.ExecContext(ctx, query, amount, userID, asset, amount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decrease locked balance: %w", err)
                }</span>

                <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get rows affected: %w", err)
                }</span>

                <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("insufficient locked balance or balance not found for user %s and asset %s", userID, asset)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// LockedByUserIdAndAsset lock user asset available amount (decrease) and add locked amount, if available not enough return error.
func (b balanceRepository) LockedByUserIdAndAsset(ctx context.Context, db repository.DBExecutor, userID, asset string, amount float64) error <span class="cov0" title="0">{
        // atomic updatedecrease available and increase locked
        query := `UPDATE balances 
                          SET available = available - ?, locked = locked + ? 
                          WHERE user_id = ? AND asset = ? AND available &gt;= ?`

        result, err := db.ExecContext(ctx, query, amount, amount, userID, asset, amount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to lock balance: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient available balance, asset %s", asset)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UnlockedByUserIdAndAsset unlock user asset locked amount (decrease) and add available amount, if locked not enough return error.
func (b balanceRepository) UnlockedByUserIdAndAsset(ctx context.Context, db repository.DBExecutor, userID, asset string, amount float64) error <span class="cov0" title="0">{
        // atomic update access
        query := `UPDATE balances 
                          SET locked = locked - ?, available = available + ? 
                          WHERE user_id = ? AND asset = ? AND locked &gt;= ?`

        result, err := db.ExecContext(ctx, query, amount, amount, userID, asset, amount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unlock balance: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient locked balance or balance not found for user %s and asset %s", userID, asset)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BatchCreate batch insert by userId and assets.html slice. available and locked default = 0.0
func (b balanceRepository) BatchCreate(ctx context.Context, db repository.DBExecutor, userId string, assets []string) error <span class="cov0" title="0">{
        if len(assets) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">valueStrings := make([]string, 0, len(assets))
        valueArgs := make([]interface{}, 0, len(assets)*4)

        for _, asset := range assets </span><span class="cov0" title="0">{
                valueStrings = append(valueStrings, "(?, ?, ?, ?)")
                valueArgs = append(valueArgs, userId, asset, 0.0, 0.0)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("INSERT INTO balances (user_id, asset, available, locked) VALUES %s",
                strings.Join(valueStrings, ","))

        _, err := db.ExecContext(ctx, query, valueArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to batch create balances: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b balanceRepository) UpdateAsset(ctx context.Context, db repository.DBExecutor, userId string, asset string, availableChanging float64, lockedChanging float64) error <span class="cov0" title="0">{
        query := `UPDATE balances 
                          SET available = available + ?, locked = locked + ? 
                          WHERE user_id = ? AND asset = ?`

        result, err := db.ExecContext(ctx, query, availableChanging, lockedChanging, userId, asset)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to UpdateAsset balance: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get UpdateAsset affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("userId %s and asset %s not found", userId, asset)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repositoryImpl

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/johnny1110/crypto-exchange/repository"
        "math"
        "strings"
        "time"
)

type orderRepository struct {
}

func NewOrderRepository() repository.IOrderRepository <span class="cov0" title="0">{
        return &amp;orderRepository{}
}</span>

func (o orderRepository) Insert(ctx context.Context, db repository.DBExecutor, order *dto.Order) error <span class="cov0" title="0">{
        query := `INSERT INTO orders (
                id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ,?)`

        _, err := db.ExecContext(ctx, query,
                order.ID,
                order.UserID,
                order.Market,
                order.Side,
                order.Price,
                order.OriginalSize,
                order.RemainingSize,
                order.QuoteAmount,
                order.AvgDealtPrice,
                order.Type,
                order.Mode,
                order.Status,
                order.CreatedAt,
                order.UpdatedAt,
                order.FeeAsset,
                order.FeeRate,
                order.Fees,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert order: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o orderRepository) Update(ctx context.Context, db repository.DBExecutor, order *dto.Order) error <span class="cov0" title="0">{
        query := `UPDATE orders SET 
                remaining_size = ?, status = ?, updated_at = ?
                WHERE id = ?`

        result, err := db.ExecContext(ctx, query,
                order.RemainingSize,
                order.Status,
                time.Now(),
                order.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update order: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("order with id %s not found", order.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o orderRepository) GetOrderByOrderId(ctx context.Context, db repository.DBExecutor, orderId string) (*dto.Order, error) <span class="cov0" title="0">{
        query := `SELECT id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
                FROM orders WHERE id = ?`

        var order dto.Order

        err := db.QueryRowContext(ctx, query, orderId).Scan(
                &amp;order.ID,
                &amp;order.UserID,
                &amp;order.Market,
                &amp;order.Side,
                &amp;order.Price,
                &amp;order.OriginalSize,
                &amp;order.RemainingSize,
                &amp;order.QuoteAmount,
                &amp;order.AvgDealtPrice,
                &amp;order.Type,
                &amp;order.Mode,
                &amp;order.Status,
                &amp;order.CreatedAt,
                &amp;order.UpdatedAt,
                &amp;order.FeeAsset,
                &amp;order.FeeRate,
                &amp;order.Fees,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("order with id %s not found", orderId)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get order by id: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;order, nil</span>
}

func (o orderRepository) GetOrdersByUserIdAndStatus(ctx context.Context, db repository.DBExecutor, userId string, status model.OrderStatus) ([]*dto.Order, error) <span class="cov0" title="0">{
        query := `SELECT id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
                FROM orders WHERE user_id = ? AND status = ? 
                ORDER BY created_at DESC`

        rows, err := db.QueryContext(ctx, query, userId, string(status))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*dto.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order := &amp;dto.Order{}

                err := rows.Scan(
                        &amp;order.ID,
                        &amp;order.UserID,
                        &amp;order.Market,
                        &amp;order.Side,
                        &amp;order.Price,
                        &amp;order.OriginalSize,
                        &amp;order.RemainingSize,
                        &amp;order.QuoteAmount,
                        &amp;order.AvgDealtPrice,
                        &amp;order.Type,
                        &amp;order.Mode,
                        &amp;order.Status,
                        &amp;order.CreatedAt,
                        &amp;order.UpdatedAt,
                        &amp;order.FeeAsset,
                        &amp;order.FeeRate,
                        &amp;order.Fees,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan order: %w", err)
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("row iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (o orderRepository) GetOrdersByUserIdAndStatuses(ctx context.Context, db repository.DBExecutor, id string, statuses []model.OrderStatus) ([]*dto.Order, error) <span class="cov0" title="0">{
        if len(statuses) == 0 </span><span class="cov0" title="0">{
                return []*dto.Order{}, nil
        }</span>

        // create IN prepare statement
        <span class="cov0" title="0">placeholders := make([]string, len(statuses))
        args := make([]interface{}, len(statuses)+1)
        args[0] = id // user_id

        for i, status := range statuses </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i+1] = string(status)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`SELECT id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
                FROM orders WHERE user_id = ? AND status IN (%s) 
                ORDER BY created_at DESC`, strings.Join(placeholders, ","))

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*dto.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order := &amp;dto.Order{}

                err := rows.Scan(
                        &amp;order.ID,
                        &amp;order.UserID,
                        &amp;order.Market,
                        &amp;order.Side,
                        &amp;order.Price,
                        &amp;order.OriginalSize,
                        &amp;order.RemainingSize,
                        &amp;order.QuoteAmount,
                        &amp;order.AvgDealtPrice,
                        &amp;order.Type,
                        &amp;order.Mode,
                        &amp;order.Status,
                        &amp;order.CreatedAt,
                        &amp;order.UpdatedAt,
                        &amp;order.FeeAsset,
                        &amp;order.FeeRate,
                        &amp;order.Fees,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan order: %w", err)
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("row iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (o orderRepository) SyncTradeMatchingResult(ctx context.Context, db repository.DBExecutor, orderId string, decreasingSize, dealtQuoteAmount float64, fees float64) error <span class="cov0" title="0">{
        query := `UPDATE orders SET 
                remaining_size = remaining_size - ?, 
                quote_amount = quote_amount + ?,
                avg_dealt_price = (quote_amount + ?) / (original_size - remaining_size + ?),
                status = CASE           
                                                            WHEN original_size = 0 THEN ?
                                                  WHEN remaining_size - ? = 0 THEN ?
                                                                WHEN remaining_size - ? &lt; original_size THEN ?
                                                                ELSE status END
                   , fees = fees + ?
                   , updated_at = ?
                WHERE id = ?`

        result, err := db.ExecContext(ctx, query,
                decreasingSize,
                dealtQuoteAmount,
                dealtQuoteAmount,
                decreasingSize,
                model.ORDER_STATUS_FILLED,
                decreasingSize,
                model.ORDER_STATUS_FILLED,
                decreasingSize,
                model.ORDER_STATUS_PARTIAL,
                fees,
                time.Now(),
                orderId,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to SyncTradeMatchingResult order: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("order with id %s not found", orderId)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (o orderRepository) CancelOrder(ctx context.Context, db repository.DBExecutor, orderId string, remainingSize float64) error <span class="cov0" title="0">{
        query := `UPDATE orders SET 
                remaining_size = ?, status = ?, updated_at = ?
                WHERE id = ?`

        result, err := db.ExecContext(ctx, query,
                remainingSize,
                model.ORDER_STATUS_CANCELED,
                time.Now(),
                orderId,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to cancel order: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("order with id %s not found", orderId)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o orderRepository) UpdateOriginalSize(ctx context.Context, db repository.DBExecutor, orderId string, originalSize float64) error <span class="cov0" title="0">{
        query := `UPDATE orders SET 
                original_size = ?, updated_at = ?
                WHERE id = ?`

        result, err := db.ExecContext(ctx, query,
                originalSize,
                time.Now(),
                orderId,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update order original size: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("order with id %s not found", orderId)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (o orderRepository) GetOrdersByMarketAndStatuses(ctx context.Context, db repository.DBExecutor, market string, statuses []model.OrderStatus) ([]*dto.Order, error) <span class="cov0" title="0">{
        if len(statuses) == 0 </span><span class="cov0" title="0">{
                return []*dto.Order{}, nil
        }</span>

        // create IN prepare statement
        <span class="cov0" title="0">placeholders := make([]string, len(statuses))
        args := make([]interface{}, len(statuses)+1)
        args[0] = market

        for i, status := range statuses </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i+1] = string(status)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`SELECT id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
                FROM orders WHERE market = ? AND status IN (%s) 
                ORDER BY created_at DESC`, strings.Join(placeholders, ","))

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*dto.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order := &amp;dto.Order{}

                err := rows.Scan(
                        &amp;order.ID,
                        &amp;order.UserID,
                        &amp;order.Market,
                        &amp;order.Side,
                        &amp;order.Price,
                        &amp;order.OriginalSize,
                        &amp;order.RemainingSize,
                        &amp;order.QuoteAmount,
                        &amp;order.AvgDealtPrice,
                        &amp;order.Type,
                        &amp;order.Mode,
                        &amp;order.Status,
                        &amp;order.CreatedAt,
                        &amp;order.UpdatedAt,
                        &amp;order.FeeAsset,
                        &amp;order.FeeRate,
                        &amp;order.Fees,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan order: %w", err)
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("row iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (o orderRepository) GetOrdersByUserIdAndMarketAndStatuses(ctx context.Context, db repository.DBExecutor, userId string, market string, statuses []model.OrderStatus) ([]*dto.Order, error) <span class="cov0" title="0">{
        if len(statuses) == 0 </span><span class="cov0" title="0">{
                return []*dto.Order{}, nil
        }</span>

        // create IN prepare statement
        <span class="cov0" title="0">placeholders := make([]string, len(statuses))
        args := make([]interface{}, len(statuses)+2)
        args[0] = userId
        args[1] = market

        for i, status := range statuses </span><span class="cov0" title="0">{
                placeholders[i] = "?"
                args[i+2] = string(status)
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`SELECT id, user_id, market, side, price, original_size, remaining_size, 
                quote_amount, avg_dealt_price, type, mode, status, created_at, updated_at, fee_asset, fee_rate, fees
                FROM orders WHERE user_id = ? AND market = ? AND status IN (%s) 
                ORDER BY created_at DESC`, strings.Join(placeholders, ","))

        rows, err := db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*dto.Order
        for rows.Next() </span><span class="cov0" title="0">{
                order := &amp;dto.Order{}

                err := rows.Scan(
                        &amp;order.ID,
                        &amp;order.UserID,
                        &amp;order.Market,
                        &amp;order.Side,
                        &amp;order.Price,
                        &amp;order.OriginalSize,
                        &amp;order.RemainingSize,
                        &amp;order.QuoteAmount,
                        &amp;order.AvgDealtPrice,
                        &amp;order.Type,
                        &amp;order.Mode,
                        &amp;order.Status,
                        &amp;order.CreatedAt,
                        &amp;order.UpdatedAt,
                        &amp;order.FeeAsset,
                        &amp;order.FeeRate,
                        &amp;order.Fees,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan order: %w", err)
                }</span>

                <span class="cov0" title="0">orders = append(orders, order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("row iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (o orderRepository) PaginationQuery(ctx context.Context, db repository.DBExecutor, query *dto.GetOrdersQueryReq, statuses []model.OrderStatus, endTime time.Time) (*dto.PaginationResp[*dto.Order], error) <span class="cov0" title="0">{
        if query == nil || len(statuses) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query parameters")
        }</span>

        // Build WHERE conditions
        <span class="cov0" title="0">var conditions []string
        var args []interface{}

        // user_id is required
        conditions = append(conditions, "user_id = ?")
        args = append(args, query.UserID)

        // status filter (multiple values)
        statusPlaceholders := make([]string, len(statuses))
        for i, status := range statuses </span><span class="cov0" title="0">{
                statusPlaceholders[i] = "?"
                args = append(args, string(status))
        }</span>
        <span class="cov0" title="0">conditions = append(conditions, fmt.Sprintf("status IN (%s)", strings.Join(statusPlaceholders, ",")))

        // market filter (optional)
        if query.Market != "" </span><span class="cov0" title="0">{
                conditions = append(conditions, "market = ?")
                args = append(args, query.Market)
        }</span>

        // side filter (optional)
        <span class="cov0" title="0">if query.Side != 0 </span><span class="cov0" title="0">{ // assuming 0 is not a valid side value
                conditions = append(conditions, "side = ?")
                args = append(args, int(query.Side))
        }</span>

        // time filter for closed orders (if endTime is set)
        <span class="cov0" title="0">if !endTime.IsZero() </span><span class="cov0" title="0">{
                conditions = append(conditions, "created_at &gt;= ?")
                args = append(args, endTime)
        }</span>

        <span class="cov0" title="0">whereClause := strings.Join(conditions, " AND ")

        // Count total records
        countSQL := fmt.Sprintf("SELECT COUNT(*) FROM orders WHERE %s", whereClause)
        var total int64
        if err := db.QueryRowContext(ctx, countSQL, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count orders: %w", err)
        }</span>

        // Calculate pagination
        <span class="cov0" title="0">offset := (query.CurrentPage - 1) * query.PageSize
        totalPages := int64(math.Ceil(float64(total) / float64(query.PageSize)))

        // Query data with pagination
        dataSQL := fmt.Sprintf(`
        SELECT id, user_id, market, side, price, original_size, remaining_size, 
               quote_amount, avg_dealt_price, type, mode, status, fee_rate, 
               fees, fee_asset, created_at, updated_at 
        FROM orders 
        WHERE %s 
        ORDER BY created_at DESC 
        LIMIT ? OFFSET ?`, whereClause)

        args = append(args, query.PageSize, offset)

        rows, err := db.QueryContext(ctx, dataSQL, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*dto.Order
        for rows.Next() </span><span class="cov0" title="0">{
                var order dto.Order
                var feeAsset sql.NullString

                err = rows.Scan(
                        &amp;order.ID,
                        &amp;order.UserID,
                        &amp;order.Market,
                        &amp;order.Side,
                        &amp;order.Price,
                        &amp;order.OriginalSize,
                        &amp;order.RemainingSize,
                        &amp;order.QuoteAmount,
                        &amp;order.AvgDealtPrice,
                        &amp;order.Type,
                        &amp;order.Mode,
                        &amp;order.Status,
                        &amp;order.FeeRate,
                        &amp;order.Fees,
                        &amp;feeAsset,
                        &amp;order.CreatedAt,
                        &amp;order.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan order: %w", err)
                }</span>

                // Handle nullable fee_asset
                <span class="cov0" title="0">if feeAsset.Valid </span><span class="cov0" title="0">{
                        order.FeeAsset = feeAsset.String
                }</span>

                <span class="cov0" title="0">orders = append(orders, &amp;order)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>

        // Build response
        <span class="cov0" title="0">response := &amp;dto.PaginationResp[*dto.Order]{
                Result:      orders,
                Total:       total,
                CurrentPage: query.CurrentPage,
                PageSize:    query.PageSize,
                TotalPages:  totalPages,
                HasNext:     query.CurrentPage &lt; totalPages,
                HasPrev:     query.CurrentPage &gt; 1,
        }

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repositoryImpl

import (
        "context"
        "fmt"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/repository"
        "strings"
        "time"
)

type tradeRepository struct {
}

func NewTradeRepository() repository.ITradeRepository <span class="cov0" title="0">{
        return &amp;tradeRepository{}
}</span>

func (t tradeRepository) BatchInsert(ctx context.Context, db repository.DBExecutor, trades []book.Trade) error <span class="cov0" title="0">{
        if len(trades) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">valueStrings := make([]string, 0, len(trades))
        valueArgs := make([]interface{}, 0, len(trades)*8) // 8 columns

        for _, trade := range trades </span><span class="cov0" title="0">{
                valueStrings = append(valueStrings, "(?, ?, ?, ?, ?, ?, ?, ?)")
                valueArgs = append(valueArgs,
                        trade.Market,
                        trade.AskOrderID,
                        trade.BidOrderID,
                        trade.AskFeeRate,
                        trade.BidFeeRate,
                        trade.Price,
                        trade.Size,
                        trade.Timestamp,
                )
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf("INSERT INTO trades (market, ask_order_id, bid_order_id, ask_fee_rate, bid_fee_rate, price, size, timestamp) VALUES %s",
                strings.Join(valueStrings, ","))

        _, err := db.ExecContext(ctx, query, valueArgs...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to batch insert trades: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (t tradeRepository) GetMarketLatestPrice(ctx context.Context, db repository.DBExecutor, marketName string) (float64, error) <span class="cov0" title="0">{
        query := `SELECT price
                FROM trades WHERE market = ? 
                ORDER BY timestamp DESC LIMIT 1`

        rows, err := db.QueryContext(ctx, query, marketName)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, fmt.Errorf("failed to query latest price: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var price float64
        if rows.Next() </span><span class="cov0" title="0">{
                if err := rows.Scan(&amp;price); err != nil </span><span class="cov0" title="0">{
                        return 0.0, fmt.Errorf("failed to scan price: %w", err)
                }</span>
                <span class="cov0" title="0">return price, nil</span>
        }

        <span class="cov0" title="0">return 0.0, fmt.Errorf("no price found for market: %s", marketName)</span>
}

func (t tradeRepository) GetMarketPriceTimesAgo(ctx context.Context, db repository.DBExecutor, market string, timeAgo time.Time) (float64, error) <span class="cov0" title="0">{
        query := `
        SELECT price 
        FROM trades 
        WHERE market = ? AND timestamp &lt;= ? 
        ORDER BY timestamp DESC 
        LIMIT 1`

        var price float64
        err := db.QueryRowContext(ctx, query, market, timeAgo).Scan(&amp;price)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return price, nil</span>
}

func (t tradeRepository) GetMarketVolumeByTimeRange(ctx context.Context, db repository.DBExecutor, market string, startTime time.Time, endTime time.Time) (float64, error) <span class="cov0" title="0">{
        query := `
        SELECT COALESCE(SUM(size), 0) 
        FROM trades 
        WHERE market = ? AND timestamp BETWEEN ? AND ?`

        var volume float64
        err := db.QueryRowContext(ctx, query, market, startTime, endTime).Scan(&amp;volume)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return volume, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repositoryImpl

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/repository"
)

type userRepository struct {
}

func NewUserRepository() repository.IUserRepository <span class="cov0" title="0">{
        return &amp;userRepository{}
}</span>

func (u userRepository) GetUserById(ctx context.Context, db repository.DBExecutor, userId string) (*dto.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, password_hash, vip_level, maker_fee, taker_fee, created_at FROM users WHERE id = ?`

        var user dto.User

        err := db.QueryRowContext(ctx, query, userId).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.VipLevel,
                &amp;user.MakerFee,
                &amp;user.TakerFee,
                &amp;user.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user with id %s not found", userId)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by id: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (u userRepository) GetUserByUsername(ctx context.Context, db repository.DBExecutor, username string) (*dto.User, error) <span class="cov0" title="0">{
        query := `SELECT id, username, password_hash, vip_level, maker_fee, taker_fee, created_at FROM users WHERE username = ?`

        var user dto.User

        err := db.QueryRowContext(ctx, query, username).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.PasswordHash,
                &amp;user.VipLevel,
                &amp;user.MakerFee,
                &amp;user.TakerFee,
                &amp;user.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user with username %s not found", username)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by username: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

func (u userRepository) Insert(ctx context.Context, db repository.DBExecutor, user *dto.User) error <span class="cov0" title="0">{
        query := `INSERT INTO users (id, username, password_hash, vip_level, maker_fee, taker_fee) 
                        VALUES (?, ?, ?, ?, ?, ?)`

        _, err := db.ExecContext(ctx, query, user.ID, user.Username, user.PasswordHash, user.VipLevel, user.MakerFee, user.TakerFee)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert user: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u userRepository) UpdatePwd(ctx context.Context, db repository.DBExecutor, user *dto.User) error <span class="cov0" title="0">{
        query := `UPDATE users SET password_hash = ? WHERE id = ?`

        result, err := db.ExecContext(ctx, query, user.PasswordHash, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user pwd: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user with id %s not found", user.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (u userRepository) UpdateVipLevel(ctx context.Context, db repository.DBExecutor, user *dto.User) error <span class="cov0" title="0">{
        query := `UPDATE users SET vip_level = ?, maker_fee = ?, taker_fee = ? WHERE id = ?`

        result, err := db.ExecContext(ctx, query, user.VipLevel, user.MakerFee, user.TakerFee, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user vip_level: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user with id %s not found", user.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package main

import (
        "github.com/gin-gonic/gin"
        "github.com/johnny1110/crypto-exchange/container"
        "github.com/johnny1110/crypto-exchange/controller"
        "github.com/johnny1110/crypto-exchange/middleware"
        "net/http"
)

func setupRouter(c *container.Container) *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        // add middleware
        router.Use(middleware.CORS())
        router.Use(middleware.ErrorHandler())
        router.Use(middleware.RateLimitMiddleware())

        // create controller
        userController := controller.NewUserController(c.UserService)
        balanceController := controller.NewBalanceController(c.BalanceService)
        orderController := controller.NewOrderController(c.OrderService)
        adminController := controller.NewAdminController(c.AdminService)
        orderBookController := controller.NewOrderBookController(c.OrderBookService)
        marketDataController := controller.NewMarketDataController(c.MarketDataService)

        // setup routes
        setupRoutes(router, c, userController, balanceController, orderController,
                adminController, orderBookController, marketDataController)

        return router
}</span>

func setupRoutes(
        router *gin.Engine,
        c *container.Container,
        userController *controller.UserController,
        balanceController *controller.BalanceController,
        orderController *controller.OrderController,
        adminController *controller.AdminController,
        orderBookController *controller.OrderBookController,
        marketDataController *controller.MarketDataController,
) <span class="cov0" title="0">{
        // Health check
        router.GET("/health", func(ctx *gin.Context) </span><span class="cov0" title="0">{
                ctx.JSON(http.StatusOK, gin.H{"status": "ok"})
        }</span>)

        // Public router
        <span class="cov0" title="0">public := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // user etc.
                public.POST("/users/register", userController.Register)
                public.POST("/users/login", userController.Login)
                public.GET("/orderbooks/:market/snapshot", orderBookController.OrderbooksSnapshot)
                public.GET("markets", marketDataController.GetAllMarketsData)
                public.GET("markets/:market", marketDataController.GetMarketsData)
        }</span>

        // Auth router
        <span class="cov0" title="0">private := router.Group("/api/v1")
        private.Use(middleware.AuthMiddleware(c.CredentialCache))
        </span><span class="cov0" title="0">{
                // users
                private.GET("/users/profile", userController.GetProfile)
                private.POST("/users/logout", userController.Logout)
                // balances
                private.GET("/balances", balanceController.GetBalances)
                // orders
                private.POST("/orders/:market", orderController.PlaceOrder)
                private.DELETE("/orders/:orderId", orderController.CancelOrder)
                private.GET("/orders", orderController.GetOrders)

        }</span>

        // Admin router
        <span class="cov0" title="0">admin := router.Group("/admin/api/v1")
        admin.Use(middleware.AdminMiddleware())
        </span><span class="cov0" title="0">{
                admin.POST("/manual-adjustment", adminController.ManualAdjustment)
                admin.POST("/test-make-market", adminController.TestMakeMarket)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package scheduler

import (
        "context"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/johnny1110/crypto-exchange/service/impl/amm"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
        "time"
)

type LQDTScheduler struct {
        ammExgFuncProxy amm.IAmmExchangeFuncProxy
        duration        time.Duration
        ammUser         dto.User
}

func NewLQDTScheduler(ammExgFuncProxy amm.IAmmExchangeFuncProxy, service service.IUserService, duration time.Duration) Scheduler <span class="cov0" title="0">{
        ammAccount, err := service.GetUser(context.Background(), settings.INTERNAL_AMM_ACCOUNT_ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[NewLQDTScheduler] failed to gat AMM User Data: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;LQDTScheduler{
                ammExgFuncProxy: ammExgFuncProxy,
                duration:        duration,
                ammUser:         *ammAccount,
        }</span>
}

var maxQuoteAmtPerLevelMap = map[string]float64{
        "ETH-USDT": 4000,
        "BTC-USDT": 10000,
        "DOT-USDT": 888,
}

func (L LQDTScheduler) Start() error <span class="cov0" title="0">{
        ticker := time.NewTicker(L.duration)
        log.Info("[LQDTScheduler] start")

        ctx := context.Background()
        stg, _ := amm.GetStrategy(amm.PROVIDE_LIQUIDITY, L.ammExgFuncProxy, L.ammUser)

        go func() </span><span class="cov0" title="0">{
                for range ticker.C </span><span class="cov0" title="0">{
                        for _, marketInfo := range settings.ALL_MARKETS </span><span class="cov0" title="0">{
                                maxQuoteAmtPerLevel, ok := maxQuoteAmtPerLevelMap[marketInfo.Name]
                                if !ok </span><span class="cov0" title="0">{
                                        log.Warnf("[LQDTScheduler] no found maxQuoteAmtPerLevel param for market: %s, using default 1 USDT", marketInfo.Name)
                                        maxQuoteAmtPerLevel = 1
                                }</span>
                                <span class="cov0" title="0">stg.MakeMarket(ctx, *marketInfo, maxQuoteAmtPerLevel)</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func (L LQDTScheduler) Stop() error <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package scheduler

import (
        "context"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
        "time"
)

type MarketDataScheduler struct {
        dataService  service.IMarketDataService
        cacheService service.ICacheService
        ticker       *time.Ticker
        stopCh       chan struct{}
        markets      []string
        duration     time.Duration
}

func NewMarketDataScheduler(dataService service.IMarketDataService, cache service.ICacheService, duration time.Duration) Scheduler <span class="cov0" title="0">{
        markets := make([]string, 0, len(settings.ALL_MARKETS))
        for _, info := range settings.ALL_MARKETS </span><span class="cov0" title="0">{
                markets = append(markets, info.Name)
        }</span>

        <span class="cov0" title="0">return &amp;MarketDataScheduler{
                markets:      markets,
                dataService:  dataService,
                cacheService: cache,
                stopCh:       make(chan struct{}),
                duration:     duration,
        }</span>
}

func (s *MarketDataScheduler) Start() error <span class="cov0" title="0">{
        log.Printf("[MarketDataScheduler] Starting scheduler for markets: %v", s.markets)
        ctx := context.Background()
        s.updateMarketData(ctx)

        s.ticker = time.NewTicker(s.duration)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-s.ticker.C:<span class="cov0" title="0">
                                s.updateMarketData(ctx)</span>
                        case &lt;-s.stopCh:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func (s *MarketDataScheduler) Stop() error <span class="cov0" title="0">{
        if s.ticker != nil </span><span class="cov0" title="0">{
                s.ticker.Stop()
        }</span>
        <span class="cov0" title="0">close(s.stopCh)
        log.Info("[MarketDataScheduler] stopped")
        return nil</span>
}

func (s *MarketDataScheduler) updateMarketData(ctx context.Context) <span class="cov0" title="0">{
        log.Info("[MarketDataScheduler] Updating market data...")

        for _, market := range s.markets </span><span class="cov0" title="0">{
                marketData, err := s.dataService.CalculateMarketData(ctx, market)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error calculating data for market %s: %v", market, err)
                        continue</span>
                }
                <span class="cov0" title="0">cacheKey := settings.MARKET_DATA_CACHE.Apply(market)
                s.cacheService.Update(cacheKey, marketData)
                log.Printf("Updated data for market: %s, price: %.4f, change: %.4f, volume: %.2f",
                        market, marketData.LatestPrice, marketData.PriceChange24H, marketData.TotalVolume24H)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package scheduler

import (
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/labstack/gommon/log"
        "time"
)

type orderBookSnapshotScheduler struct {
        engine   *core.MatchingEngine
        duration time.Duration
}

func NewOrderBookSnapshotScheduler(engine *core.MatchingEngine, duration time.Duration) Scheduler <span class="cov0" title="0">{
        return &amp;orderBookSnapshotScheduler{
                engine:   engine,
                duration: duration,
        }
}</span>

func (o orderBookSnapshotScheduler) Start() error <span class="cov0" title="0">{
        ticker := time.NewTicker(o.duration)
        log.Info("[OrderBookSnapshotScheduler] start")

        go func() </span><span class="cov0" title="0">{
                for range ticker.C </span><span class="cov0" title="0">{
                        for _, market := range o.engine.Markets() </span><span class="cov0" title="0">{
                                ob, err := o.engine.GetOrderBook(market)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Errorf("[BookSnapshotScheduler] StartSnapshotRefresher: GetOrderBook err: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        ob.RefreshSnapshot()
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">return nil</span>
}

func (o orderBookSnapshotScheduler) Stop() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package security

import (
        "errors"
        "github.com/johnny1110/crypto-exchange/dto"
)

type CredentialCache struct {
        // token: userId
        tokenCache map[string]*dto.User
}

func NewCredentialCache() *CredentialCache <span class="cov0" title="0">{
        return &amp;CredentialCache{
                tokenCache: make(map[string]*dto.User),
        }
}</span>

func (c *CredentialCache) Put(token string, user *dto.User) <span class="cov0" title="0">{
        c.tokenCache[token] = user
}</span>

func (c *CredentialCache) Delete(token string) <span class="cov0" title="0">{
        delete(c.tokenCache, token)
}</span>

func (c *CredentialCache) Get(token string) (*dto.User, error) <span class="cov0" title="0">{
        user, ok := c.tokenCache[token]
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("invalid credential")
        }</span>
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package serviceImpl

import (
        "context"
        "database/sql"
        "errors"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/johnny1110/crypto-exchange/repository"
        "github.com/johnny1110/crypto-exchange/service"
)

type adminService struct {
        db           *sql.DB
        userRepo     repository.IUserRepository
        balanceRepo  repository.IBalanceRepository
        orderService service.IOrderService
}

func NewIAdminService(db *sql.DB,
        userRepo repository.IUserRepository,
        balanceRepo repository.IBalanceRepository,
        orderService service.IOrderService) service.IAdminService <span class="cov0" title="0">{
        return &amp;adminService{
                db:           db,
                userRepo:     userRepo,
                balanceRepo:  balanceRepo,
                orderService: orderService,
        }
}</span>

func (as adminService) Settlement(ctx context.Context, req dto.SettlementReq) error <span class="cov0" title="0">{
        err := WithTx(ctx, as.db, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                user, err := as.userRepo.GetUserByUsername(ctx, tx, req.Username)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                        return errors.New("user not found by username")
                }</span>

                <span class="cov0" title="0">err = as.balanceRepo.ModifyAvailableByUserIdAndAsset(ctx, tx, user.ID, req.Asset, true, req.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">return err</span>
}

func (as adminService) TestAutoMakeMarket(ctx context.Context) error <span class="cov0" title="0">{
        // make some testing maker
        user := &amp;dto.User{
                Username: "market_maker",
                ID:       "1",
                VipLevel: 7,
                MakerFee: 0.0001,
                TakerFee: 0.002,
        }
        market := "ETH-USDT"
        // make 5 bid orders
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.BID,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3000,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.BID,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     2900,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.BID,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     2800,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.BID,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     2700,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.BID,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     2600,
                Size:      10,
        })

        // make 5 ask orders
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.ASK,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3500,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.ASK,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3400,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.ASK,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3300,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.ASK,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3200,
                Size:      10,
        })
        _, _ = as.orderService.PlaceOrder(ctx, market, user, &amp;dto.OrderReq{
                Side:      model.ASK,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     3100,
                Size:      10,
        })

        return nil
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package amm

import (
        "context"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/market"
)

type AutoMarketStrategy interface {
        MakeMarket(ctx context.Context, market market.MarketInfo, maxQuoteAmtPerLevel float64)
}

type Strategy int

const (
        PROVIDE_LIQUIDITY = iota
        GRID_TRADING
        ARBITRAGE
)

func GetStrategy(s Strategy, proxy IAmmExchangeFuncProxy, ammUser dto.User) (AutoMarketStrategy, error) <span class="cov0" title="0">{
        switch s </span>{
        case PROVIDE_LIQUIDITY:<span class="cov0" title="0">
                return NewProvideLiquidityStrategy(proxy, ammUser), nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown strategy %d", s)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package amm

import (
        "context"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/market"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/labstack/gommon/log"
        "math"
)

// provideLiquidityStrategy provide Liquidity in OrderBook
type ProvideLiquidityStrategy struct {
        ExchangeFuncProxy IAmmExchangeFuncProxy
        AmmUID            string
        AmmUser           dto.User
}

func NewProvideLiquidityStrategy(exchangeFuncProxy IAmmExchangeFuncProxy, ammUser dto.User) AutoMarketStrategy <span class="cov0" title="0">{
        return &amp;ProvideLiquidityStrategy{
                ExchangeFuncProxy: exchangeFuncProxy,
                AmmUID:            ammUser.ID,
                AmmUser:           ammUser,
        }
}</span>

var (
        separate        = 0.001 // (Spread)0.1%
        levelAmtPerSide = 20    // ask, bid  20 
)

// PriceLevel 
type PriceLevel struct {
        Price  float64
        Volume float64
}

// MakeMarket provideLiquidityStrategy can access ExchangeFuncProxy to make market
func (p *ProvideLiquidityStrategy) MakeMarket(ctx context.Context, marketInfo market.MarketInfo, maxQuoteAmtPerLevel float64) <span class="cov0" title="0">{
        marketName := marketInfo.Name

        // 1. 
        indexPrice, err := p.ExchangeFuncProxy.GetIndexPrice(ctx, marketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("[AMM] Failed to get index price for %s: %v", marketName, err)
                return
        }</span>

        // 2. 
        <span class="cov0" title="0">balance, err := p.ExchangeFuncProxy.GetBalance(ctx, p.AmmUID, marketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("[AMM] Failed to get balance for %s: %v", marketName, err)
                return
        }</span>

        // 3. 
        <span class="cov0" title="0">openOrders, err := p.ExchangeFuncProxy.GetOpenOrders(ctx, p.AmmUID, marketName)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("[AMM] Failed to get open orders for %s: %v", marketName, err)
                return
        }</span>

        // 4. 
        <span class="cov0" title="0">idealBidLevels := p.CalculateIdealPriceLevels(indexPrice, model.BID, balance, maxQuoteAmtPerLevel)
        idealAskLevels := p.CalculateIdealPriceLevels(indexPrice, model.ASK, balance, maxQuoteAmtPerLevel)

        // 5. 
        p.AdjustOrders(ctx, marketName, openOrders, idealBidLevels, idealAskLevels)</span>
}

// calculateIdealPriceLevels 
func (p *ProvideLiquidityStrategy) CalculateIdealPriceLevels(indexPrice float64, side model.Side, balance Balance, maxQuoteAmtPerLevel float64) []PriceLevel <span class="cov2" title="2">{
        levels := make([]PriceLevel, 0, levelAmtPerSide)

        for i := 1; i &lt;= levelAmtPerSide; i++ </span><span class="cov10" title="40">{
                var price float64
                var maxVolume float64

                if side == model.BID </span><span class="cov8" title="20">{
                        // Buy side: 
                        price = indexPrice * (1 - separate*float64(i))
                        //  quote  base 
                        availableQuote := balance.quoteAvailable / float64(levelAmtPerSide)
                        if availableQuote &gt; maxQuoteAmtPerLevel </span><span class="cov8" title="20">{
                                availableQuote = maxQuoteAmtPerLevel
                        }</span>
                        <span class="cov8" title="20">maxVolume = availableQuote / price</span>
                } else<span class="cov8" title="20"> {
                        // Sell side: 
                        price = indexPrice * (1 + separate*float64(i))
                        //  base 
                        maxVolume = balance.baseAvailable / float64(levelAmtPerSide)
                        if maxVolume*price &gt; maxQuoteAmtPerLevel </span><span class="cov8" title="20">{
                                maxVolume = maxQuoteAmtPerLevel / price
                        }</span>
                }

                <span class="cov10" title="40">if maxVolume &gt; 0 </span><span class="cov10" title="40">{
                        levels = append(levels, PriceLevel{
                                Price:  p.RoundPrice(price),
                                Volume: p.RoundVolume(maxVolume),
                        })
                }</span>
        }

        <span class="cov2" title="2">return levels</span>
}

// adjustOrders 
func (p *ProvideLiquidityStrategy) AdjustOrders(ctx context.Context, marketName string,
        openOrders []*dto.Order, idealBidLevels, idealAskLevels []PriceLevel) <span class="cov0" title="0">{

        // 
        existingBids := make(map[float64]*dto.Order)
        existingAsks := make(map[float64]*dto.Order)

        for _, order := range openOrders </span><span class="cov0" title="0">{
                if order.Status == model.ORDER_STATUS_NEW || order.Status == model.ORDER_STATUS_PARTIAL </span><span class="cov0" title="0">{
                        if order.Side == model.BID </span><span class="cov0" title="0">{
                                existingBids[order.Price] = order
                        }</span> else<span class="cov0" title="0"> {
                                existingAsks[order.Price] = order
                        }</span>
                }
        }

        //  Bid 
        <span class="cov0" title="0">p.AdjustOrdersForSide(ctx, marketName, existingBids, idealBidLevels, model.BID)

        //  Ask 
        p.AdjustOrdersForSide(ctx, marketName, existingAsks, idealAskLevels, model.ASK)</span>
}

// adjustOrdersForSide 
func (p *ProvideLiquidityStrategy) AdjustOrdersForSide(ctx context.Context, marketName string,
        existingOrders map[float64]*dto.Order, idealLevels []PriceLevel, side model.Side) <span class="cov0" title="0">{

        //  map Add commentMore actions
        idealPrices := make(map[float64]PriceLevel)
        for _, level := range idealLevels </span><span class="cov0" title="0">{
                idealPrices[level.Price] = level
        }</span>

        // 1. 
        <span class="cov0" title="0">var ordersToCancel []*dto.Order
        for price, order := range existingOrders </span><span class="cov0" title="0">{
                if idealLevel, exists := idealPrices[price]; !exists </span><span class="cov0" title="0">{
                        // 
                        ordersToCancel = append(ordersToCancel, order)
                }</span> else<span class="cov0" title="0"> if math.Abs(order.RemainingSize-idealLevel.Volume) &gt; idealLevel.Volume*0.1 </span><span class="cov0" title="0">{
                        //  10%
                        ordersToCancel = append(ordersToCancel, order)
                }</span>
        }

        // 2. 
        <span class="cov0" title="0">for _, order := range ordersToCancel </span><span class="cov0" title="0">{
                _, err := p.ExchangeFuncProxy.CancelOrder(ctx, p.AmmUID, order.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to cancel order %s: %v", order.ID, err)
                        continue</span>
                }
                <span class="cov0" title="0">delete(existingOrders, order.Price)
                log.Debugf("Canceled order: %s at price %f", order.ID, order.Price)</span>
        }

        // 3. 
        <span class="cov0" title="0">for _, idealLevel := range idealLevels </span><span class="cov0" title="0">{
                if _, exists := existingOrders[idealLevel.Price]; !exists </span><span class="cov0" title="0">{
                        // 
                        err := p.PlaceNewOrder(ctx, marketName, idealLevel.Price, idealLevel.Volume, side)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Failed to place new order at price %f: %v", idealLevel.Price, err)
                        }</span>
                }
        }
}

// placeNewOrder 
func (p *ProvideLiquidityStrategy) PlaceNewOrder(ctx context.Context, marketName string,
        price, volume float64, side model.Side) error <span class="cov0" title="0">{

        orderReq := &amp;dto.OrderReq{
                Side:      side,
                OrderType: model.LIMIT,
                Mode:      model.MAKER,
                Price:     price,
                Size:      volume,
        }

        err := p.ExchangeFuncProxy.PlaceOrder(ctx, p.AmmUser, marketName, orderReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("[AMM] failed to place order: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debugf("[AMM] Placed new %s order: price=%f, volume=%f",
                map[model.Side]string{model.BID: "BUY", model.ASK: "SELL"}[side], price, volume)

        return nil</span>
}

// roundPrice 
func (p *ProvideLiquidityStrategy) RoundPrice(price float64) float64 <span class="cov10" title="40">{
        // 
        if price &gt;= 1000 </span><span class="cov10" title="40">{
                return math.Round(price*100) / 100 // 2 
        }</span> else<span class="cov0" title="0"> if price &gt;= 10 </span><span class="cov0" title="0">{
                return math.Round(price*1000) / 1000 // 3 
        }</span> else<span class="cov0" title="0"> {
                return math.Round(price*10000) / 10000 // 4 
        }</span>
}

// roundVolume 
func (p *ProvideLiquidityStrategy) RoundVolume(volume float64) float64 <span class="cov10" title="40">{
        if volume &gt;= 1 </span><span class="cov0" title="0">{
                return math.Round(volume*1000) / 1000 // 3 
        }</span> else<span class="cov10" title="40"> {
                return math.Round(volume*10000) / 10000 // 4 
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package amm

import (
        "context"
        "encoding/json"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/labstack/gommon/log"
        "io"
        "net/http"
)

type Balance struct {
        baseAsset      string  // ex: BTC, ETH
        quoteAsset     string  // ex: USDT, USDC
        baseAvailable  float64 // able to place order
        baseLocked     float64 // locked by opening order
        quoteAvailable float64 // able to place order
        quoteLocked    float64 // locked by opening order
}

func NewBalance(baseAsset, quoteAsset string, baseAva, baseLocked, quoteAva, quoteLocked float64) *Balance <span class="cov10" title="2">{
        return &amp;Balance{
                baseAsset:      baseAsset,
                quoteAsset:     quoteAsset,
                baseAvailable:  baseAva,
                baseLocked:     baseLocked,
                quoteAvailable: quoteAva,
                quoteLocked:    quoteLocked,
        }
}</span>

type IAmmExchangeFuncProxy interface {
        GetBalance(ctx context.Context, ammUID string, marketName string) (Balance, error)
        GetIndexPrice(ctx context.Context, symbol string) (float64, error)
        GetOrderBookSnapshot(ctx context.Context, marketName string) (book.BookSnapshot, error)
        GetOpenOrders(ctx context.Context, ammUID string, marketName string) ([]*dto.Order, error)
        PlaceOrder(ctx context.Context, user dto.User, marketName string, placeOrderReq *dto.OrderReq) error
        CancelOrder(ctx context.Context, ammUID string, orderId string) (*dto.Order, error)
}

type AmmExchangeFuncProxyImpl struct {
        orderBookService service.IOrderBookService
        balanceService   service.IBalanceService
        orderService     service.IOrderService
        userService      service.IUserService
        httpClient       *http.Client
}

func NewAmmExchangeFuncProxyImpl(orderBookService service.IOrderBookService,
        balanceService service.IBalanceService,
        orderService service.IOrderService,
        userService service.IUserService,
        httpClient *http.Client) IAmmExchangeFuncProxy <span class="cov0" title="0">{
        return &amp;AmmExchangeFuncProxyImpl{
                orderBookService: orderBookService,
                balanceService:   balanceService,
                orderService:     orderService,
                userService:      userService,
                httpClient:       httpClient,
        }
}</span>

func (a AmmExchangeFuncProxyImpl) GetBalance(ctx context.Context, ammUID string, marketName string) (Balance, error) <span class="cov0" title="0">{
        balances, err := a.balanceService.GetBalances(ctx, ammUID)
        if err != nil </span><span class="cov0" title="0">{
                return Balance{}, err
        }</span>
        <span class="cov0" title="0">base, quote, err := a.orderBookService.GetBaseQuoteAssets(ctx, marketName)
        if err != nil </span><span class="cov0" title="0">{
                return Balance{}, err
        }</span>

        <span class="cov0" title="0">var baseAva, baseLocked, quoteAva, quoteLocked float64
        for _, balance := range balances </span><span class="cov0" title="0">{
                if balance.Asset == base </span><span class="cov0" title="0">{
                        baseAva = balance.Available
                        baseLocked = balance.Locked
                }</span>
                <span class="cov0" title="0">if balance.Asset == quote </span><span class="cov0" title="0">{
                        quoteAva = balance.Available
                        quoteLocked = balance.Locked
                }</span>
        }

        <span class="cov0" title="0">return Balance{
                base,
                quote,
                baseAva,
                baseLocked,
                quoteAva,
                quoteLocked}, nil</span>
}

// MarketSummary represents the structure of market data from BTSE API
type MarketSummary struct {
        Symbol              string      `json:"symbol"`
        Last                float64     `json:"last"`
        LowestAsk           float64     `json:"lowestAsk"`
        HighestBid          float64     `json:"highestBid"`
        PercentageChange    float64     `json:"percentageChange"`
        Volume              float64     `json:"volume"`
        High24Hr            float64     `json:"high24Hr"`
        Low24Hr             float64     `json:"low24Hr"`
        Base                string      `json:"base"`
        Quote               string      `json:"quote"`
        Active              bool        `json:"active"`
        Size                float64     `json:"size"`
        MinValidPrice       float64     `json:"minValidPrice"`
        MinPriceIncrement   float64     `json:"minPriceIncrement"`
        MinOrderSize        float64     `json:"minOrderSize"`
        MaxOrderSize        float64     `json:"maxOrderSize"`
        MinSizeIncrement    float64     `json:"minSizeIncrement"`
        OpenInterest        float64     `json:"openInterest"`
        OpenInterestUSD     float64     `json:"openInterestUSD"`
        ContractStart       int64       `json:"contractStart"`
        ContractEnd         int64       `json:"contractEnd"`
        TimeBasedContract   bool        `json:"timeBasedContract"`
        OpenTime            int64       `json:"openTime"`
        CloseTime           int64       `json:"closeTime"`
        StartMatching       int64       `json:"startMatching"`
        InactiveTime        int64       `json:"inactiveTime"`
        FundingRate         float64     `json:"fundingRate"`
        ContractSize        float64     `json:"contractSize"`
        MaxPosition         float64     `json:"maxPosition"`
        MinRiskLimit        float64     `json:"minRiskLimit"`
        MaxRiskLimit        float64     `json:"maxRiskLimit"`
        AvailableSettlement interface{} `json:"availableSettlement"`
        Futures             bool        `json:"futures"`
        IsMarketOpenToOtc   bool        `json:"isMarketOpenToOtc"`
        IsMarketOpenToSpot  bool        `json:"isMarketOpenToSpot"`
}

// GetIndexPrice retrieves the latest price for a given symbol from BTSE API
func (a *AmmExchangeFuncProxyImpl) GetIndexPrice(ctx context.Context, symbol string) (float64, error) <span class="cov0" title="0">{
        const apiURL = "https://api.btse.com/spot/api/v3.2/market_summary"

        // Create HTTP request with context
        req, err := http.NewRequestWithContext(ctx, "GET", apiURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")
        req.Header.Set("User-Agent", "Go-HTTP-Client/1.1")

        // Make the HTTP request
        resp, err := a.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to make request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check response status
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("API returned status code: %d", resp.StatusCode)
        }</span>

        // Read response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var marketSummaries []MarketSummary
        if err := json.Unmarshal(body, &amp;marketSummaries); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse JSON response: %w", err)
        }</span>

        // Find the symbol in the response
        <span class="cov0" title="0">for _, market := range marketSummaries </span><span class="cov0" title="0">{
                if market.Symbol == symbol </span><span class="cov0" title="0">{
                        if !market.Active </span><span class="cov0" title="0">{
                                return 0, fmt.Errorf("market for symbol %s is not active", symbol)
                        }</span>
                        <span class="cov0" title="0">return market.Last, nil</span>
                }
        }

        <span class="cov0" title="0">log.Warnf("[GetIndexPrcie] not found by BTSE API, using Default")

        return a.orderBookService.GetLatestPrice(ctx, symbol)</span>
}

func (a AmmExchangeFuncProxyImpl) GetOrderBookSnapshot(ctx context.Context, marketName string) (book.BookSnapshot, error) <span class="cov0" title="0">{
        snapshot, err := a.orderBookService.GetSnapshot(ctx, marketName)
        return *snapshot, err

}</span>

func (a AmmExchangeFuncProxyImpl) GetOpenOrders(ctx context.Context, ammUID string, marketName string) ([]*dto.Order, error) <span class="cov0" title="0">{
        return a.orderService.QueryOrderByMarket(ctx, ammUID, marketName, true)
}</span>

func (a AmmExchangeFuncProxyImpl) PlaceOrder(ctx context.Context, user dto.User, marketName string, placeOrderReq *dto.OrderReq) error <span class="cov0" title="0">{
        _, err := a.orderService.PlaceOrder(ctx, marketName, &amp;user, placeOrderReq)
        return err
}</span>

func (a AmmExchangeFuncProxyImpl) CancelOrder(ctx context.Context, ammUID string, orderId string) (*dto.Order, error) <span class="cov0" title="0">{
        return a.orderService.CancelOrder(ctx, ammUID, orderId)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package test

import (
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "time"
)

func fake_orders(userId string, market string) []*dto.Order <span class="cov0" title="0">{
        orders := make([]*dto.Order, 0, 5)
        order1 := &amp;dto.Order{
                ID:            "1",
                UserID:        userId,
                Market:        market,
                Side:          model.BID,
                Price:         2999,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "ETH",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order2 := &amp;dto.Order{
                ID:            "2",
                UserID:        userId,
                Market:        market,
                Side:          model.BID,
                Price:         2998,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "ETH",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order3 := &amp;dto.Order{
                ID:            "3",
                UserID:        userId,
                Market:        market,
                Side:          model.BID,
                Price:         2997,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "ETH",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order4 := &amp;dto.Order{
                ID:            "4",
                UserID:        userId,
                Market:        market,
                Side:          model.BID,
                Price:         2996,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order5 := &amp;dto.Order{
                ID:            "5",
                UserID:        userId,
                Market:        market,
                Side:          model.BID,
                Price:         2995,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        // Sell ____________________________________________________________

        order6 := &amp;dto.Order{
                ID:            "6",
                UserID:        userId,
                Market:        market,
                Side:          model.ASK,
                Price:         3001,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order7 := &amp;dto.Order{
                ID:            "7",
                UserID:        userId,
                Market:        market,
                Side:          model.ASK,
                Price:         3002,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order8 := &amp;dto.Order{
                ID:            "8",
                UserID:        userId,
                Market:        market,
                Side:          model.ASK,
                Price:         3003,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order9 := &amp;dto.Order{
                ID:            "9",
                UserID:        userId,
                Market:        market,
                Side:          model.ASK,
                Price:         3004,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        order10 := &amp;dto.Order{
                ID:            "10",
                UserID:        userId,
                Market:        market,
                Side:          model.ASK,
                Price:         3005,
                OriginalSize:  0.1,
                RemainingSize: 0.1,
                QuoteAmount:   0,
                AvgDealtPrice: 0.0,
                Type:          model.LIMIT,
                Mode:          model.MAKER,
                Status:        model.ORDER_STATUS_NEW,
                FeeRate:       0.0001,
                Fees:          0.0,
                FeeAsset:      "USDT",
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }

        orders = append(orders, order1)
        orders = append(orders, order2)
        orders = append(orders, order3)
        orders = append(orders, order4)
        orders = append(orders, order5)
        orders = append(orders, order6)
        orders = append(orders, order7)
        orders = append(orders, order8)
        orders = append(orders, order9)
        orders = append(orders, order10)

        return orders
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package test

import (
        "context"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/service/impl/amm"
        "github.com/labstack/gommon/log"
)

type MockExgFuncProxyImpl struct {
}

func (m MockExgFuncProxyImpl) GetBalance(ctx context.Context, ammUID string, marketName string) (amm.Balance, error) <span class="cov0" title="0">{
        balance := amm.NewBalance("ETH", "USDT", 100, 0, 100000, 0)
        return *balance, nil
}</span>

func (m MockExgFuncProxyImpl) GetIndexPrice(ctx context.Context, symbol string) (float64, error) <span class="cov0" title="0">{
        return 3000, nil
}</span>

func (m MockExgFuncProxyImpl) GetOrderBookSnapshot(ctx context.Context, marketName string) (book.BookSnapshot, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (m MockExgFuncProxyImpl) GetOpenOrders(ctx context.Context, ammUID string, marketName string) ([]*dto.Order, error) <span class="cov0" title="0">{
        return fake_orders("U01", "ETH-USDT"), nil
}</span>

func (m MockExgFuncProxyImpl) PlaceOrder(ctx context.Context, user dto.User, marketName string, placeOrderReq *dto.OrderReq) error <span class="cov0" title="0">{
        log.Infof("[PlaceOrder] req: %v", placeOrderReq)
        return nil
}</span>

func (m MockExgFuncProxyImpl) CancelOrder(ctx context.Context, ammUID string, orderId string) (*dto.Order, error) <span class="cov0" title="0">{
        log.Infof("[CancelOrder] orderId: %s", orderId)
        return nil, nil
}</span>

func newMockExgFuncProxyImpl() amm.IAmmExchangeFuncProxy <span class="cov10" title="2">{
        return &amp;MockExgFuncProxyImpl{}
}</span>

func mockAmmUser() dto.User <span class="cov10" title="2">{
        return dto.User{
                Username: "TEST_AMM_U01",
                ID:       "1",
                MakerFee: 0.0001,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package serviceImpl

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/repository"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/labstack/gommon/log"
)

type balanceService struct {
        db                *sql.DB
        userRepo          repository.IUserRepository
        balanceRepo       repository.IBalanceRepository
        marketDataService service.IMarketDataService
}

func NewIBalanceService(db *sql.DB,
        userRepo repository.IUserRepository,
        balanceRepo repository.IBalanceRepository,
        marketDataService service.IMarketDataService) service.IBalanceService <span class="cov0" title="0">{
        return &amp;balanceService{
                db:                db,
                userRepo:          userRepo,
                balanceRepo:       balanceRepo,
                marketDataService: marketDataService,
        }
}</span>

func (bs *balanceService) GetBalances(ctx context.Context, userId string) ([]*dto.Balance, error) <span class="cov0" title="0">{
        balances, err := bs.balanceRepo.GetBalancesByUserId(ctx, bs.db, userId)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, balance := range balances </span><span class="cov0" title="0">{
                balance.ValuationCurrency = "USDT"

                if balance.Asset == "USDT" </span><span class="cov0" title="0">{
                        balance.AssetValuation = balance.Total
                        continue</span>
                }

                <span class="cov0" title="0">if balance.Total &gt; 0 </span><span class="cov0" title="0">{
                        data, err := bs.marketDataService.GetMarketData(fmt.Sprintf("%v-USDT", balance.Asset))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warnf("Get balances market data err: %v", err)
                        }</span>
                        <span class="cov0" title="0">balance.AssetValuation = data.LatestPrice * balance.Total</span>
                } else<span class="cov0" title="0"> {
                        balance.AssetValuation = 0.0
                }</span>
        }

        <span class="cov0" title="0">return balances, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package serviceImpl

import (
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/labstack/gommon/log"
        "sync"
)

type CacheService struct {
        mu   sync.RWMutex
        data map[string]interface{}
}

func NewCacheService() service.ICacheService <span class="cov0" title="0">{
        return &amp;CacheService{
                data: make(map[string]interface{}),
        }
}</span>

func (c *CacheService) Update(key string, value interface{}) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        log.Debugf("[CacheService.Update] key=%s, value=%v", key, value)
        c.data[key] = value
}</span>

func (c *CacheService) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        log.Debugf("[CacheService.Get] key=%s", key)
        data, exists := c.data[key]
        return data, exists
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package serviceImpl

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/repository"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
        "time"
)

type MarketDataService struct {
        db        *sql.DB
        tradeRepo repository.ITradeRepository
        cache     service.ICacheService
}

func (d *MarketDataService) GetAllMarketData() ([]dto.MarketData, error) <span class="cov0" title="0">{
        allMarketInfos := settings.ALL_MARKETS
        allMarketData := make([]dto.MarketData, 0, len(allMarketInfos))

        for _, marketInfo := range allMarketInfos </span><span class="cov0" title="0">{
                val, found := d.cache.Get(settings.MARKET_DATA_CACHE.Apply(marketInfo.Name))
                if found </span><span class="cov0" title="0">{
                        if marketData, ok := val.(*dto.MarketData); ok </span><span class="cov0" title="0">{
                                allMarketData = append(allMarketData, *marketData)
                        }</span>
                }
        }

        <span class="cov0" title="0">return allMarketData, nil</span>
}

func (d *MarketDataService) GetMarketData(market string) (dto.MarketData, error) <span class="cov0" title="0">{
        val, found := d.cache.Get(settings.MARKET_DATA_CACHE.Apply(market))
        if found </span><span class="cov0" title="0">{
                if marketData, ok := val.(*dto.MarketData); ok </span><span class="cov0" title="0">{
                        return *marketData, nil
                }</span> else<span class="cov0" title="0"> {
                        log.Errorf("[GetMarketData] Error market: %s", market)
                }</span>
        }
        <span class="cov0" title="0">return dto.MarketData{}, fmt.Errorf("market %s data not found", market)</span>
}

func NewMarketDataService(db *sql.DB, tradeRepo repository.ITradeRepository, cache service.ICacheService) service.IMarketDataService <span class="cov0" title="0">{
        return &amp;MarketDataService{db: db, tradeRepo: tradeRepo, cache: cache}
}</span>

func (d *MarketDataService) CalculateMarketData(ctx context.Context, market string) (*dto.MarketData, error) <span class="cov0" title="0">{
        now := time.Now()
        yesterday := now.Add(-24 * time.Hour)

        latestPrice, _ := d.getLatestPrice(ctx, market)
        price24hAgo, _ := d.getPrice24HoursAgo(ctx, market, yesterday)
        volume24h, _ := d.getVolume24Hours(ctx, market, yesterday, now)

        // calculate changing
        priceChange := 0.0
        if price24hAgo == 0 </span><span class="cov0" title="0">{
                price24hAgo = latestPrice
        }</span> else<span class="cov0" title="0"> {
                priceChange = (latestPrice - price24hAgo) / price24hAgo
        }</span>

        <span class="cov0" title="0">return &amp;dto.MarketData{
                MarketName:     market,
                LatestPrice:    latestPrice,
                PriceChange24H: priceChange,
                TotalVolume24H: volume24h,
        }, nil</span>
}

func (d *MarketDataService) getLatestPrice(ctx context.Context, market string) (float64, error) <span class="cov0" title="0">{
        return d.tradeRepo.GetMarketLatestPrice(ctx, d.db, market)
}</span>

func (d *MarketDataService) getPrice24HoursAgo(ctx context.Context, market string, yesterday time.Time) (float64, error) <span class="cov0" title="0">{
        return d.tradeRepo.GetMarketPriceTimesAgo(ctx, d.db, market, yesterday)
}</span>

func (d *MarketDataService) getVolume24Hours(ctx context.Context, market string, yesterday time.Time, now time.Time) (float64, error) <span class="cov0" title="0">{
        return d.tradeRepo.GetMarketVolumeByTimeRange(ctx, d.db, market, yesterday, now)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package serviceImpl

import (
        "context"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/johnny1110/crypto-exchange/service"
)

type orderBookService struct {
        engine *core.MatchingEngine
}

func NewIOrderBookService(engine *core.MatchingEngine) service.IOrderBookService <span class="cov0" title="0">{
        return &amp;orderBookService{
                engine: engine,
        }
}</span>

func (os orderBookService) GetSnapshot(ctx context.Context, market string) (*book.BookSnapshot, error) <span class="cov0" title="0">{
        ob, err := os.engine.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">snapshot := ob.Snapshot()
        return &amp;snapshot, nil</span>
}

func (os orderBookService) GetLatestPrice(ctx context.Context, market string) (float64, error) <span class="cov0" title="0">{
        ob, err := os.engine.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return -1.0, err
        }</span>
        <span class="cov0" title="0">return ob.LatestPrice(), nil</span>
}

func (os orderBookService) GetBaseQuoteAssets(ctx context.Context, market string) (string, string, error) <span class="cov0" title="0">{
        ob, err := os.engine.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">return ob.MarketInfo().BaseAsset, ob.MarketInfo().QuoteAsset, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package serviceImpl

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/johnny1110/crypto-exchange/repository"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/johnny1110/crypto-exchange/service/serviceHelper"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
        "time"
)

var (
        ErrInvalidInput          = errors.New("invalid input")
        ErrOrderNotFound         = errors.New("order not found")
        ErrOrderNotBelongsToUser = errors.New("order not belongs to user")
        ErrInsufficientBalance   = errors.New("insufficient balance")
        UnknownError             = errors.New("unknown error")
)

type orderService struct {
        db          *sql.DB
        engine      *core.MatchingEngine
        orderRepo   repository.IOrderRepository
        tradeRepo   repository.ITradeRepository
        balanceRepo repository.IBalanceRepository
}

func NewIOrderService(
        db *sql.DB,
        engine *core.MatchingEngine,
        orderRepo repository.IOrderRepository,
        tradeRepo repository.ITradeRepository,
        balanceRepo repository.IBalanceRepository) service.IOrderService <span class="cov0" title="0">{
        return &amp;orderService{
                db:          db,
                engine:      engine,
                orderRepo:   orderRepo,
                tradeRepo:   tradeRepo,
                balanceRepo: balanceRepo,
        }
}</span>

func (s *orderService) PlaceOrder(ctx context.Context, market string, user *dto.User, req *dto.OrderReq) (*dto.PlaceOrderResult, error) <span class="cov0" title="0">{
        // Initialize order context
        orderCtx, err := s.initializeOrderContext(market, user, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize order context: %w", err)
        }</span>

        // Execute order placement strategy
        <span class="cov0" title="0">strategy, err := s.getOrderPlacementStrategy(req.OrderType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get order placement strategy: %w", err)
        }</span>
        <span class="cov0" title="0">if err := strategy.Execute(ctx, s, orderCtx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute order placement: %w", err)
        }</span>

        <span class="cov0" title="0">return serviceHelper.WrapPlaceOrderResult(orderCtx.OrderDTO, orderCtx.Trades), nil</span>
}

func (s *orderService) initializeOrderContext(market string, user *dto.User, req *dto.OrderReq) (*dto.PlaceOrderContext, error) <span class="cov0" title="0">{
        if err := validatePlacingOrderReq(user, market, req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">baseAsset, quoteAsset, err := serviceHelper.ParseMarket(s.engine, market)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse market: %w", err)
        }</span>
        <span class="cov0" title="0">freezeAsset, freezeAmt := serviceHelper.DetermineFreezeValue(req, baseAsset, quoteAsset)
        feeAsset, feeRate := serviceHelper.DetermineFeeInfo(req, user, baseAsset, quoteAsset)

        return &amp;dto.PlaceOrderContext{
                Market:   market,
                UserID:   user.ID,
                Request:  req,
                FeeRate:  feeRate,
                FeeAsset: feeAsset,
                Assets: &amp;dto.AssetDetails{
                        BaseAsset:   baseAsset,
                        QuoteAsset:  quoteAsset,
                        FreezeAsset: freezeAsset,
                        FreezeAmt:   freezeAmt,
                },
        }, nil</span>
}

// OrderPlacementStrategy &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;

// OrderPlacementStrategy defines the interface for order placement strategies
type OrderPlacementStrategy interface {
        Execute(ctx context.Context, service *orderService, orderCtx *dto.PlaceOrderContext) error
}

// LimitOrderStrategy implements limit order placement logic
type LimitOrderStrategy struct{}

func (s *LimitOrderStrategy) Execute(ctx context.Context, service *orderService, orderCtx *dto.PlaceOrderContext) error <span class="cov0" title="0">{
        orderCtx.OrderDTO = serviceHelper.NewLimitOrderDtoByOrderCtx(orderCtx)
        return service.executeOrderPlacement(ctx, orderCtx, false)
}</span>

// MarketOrderStrategy implements market order placement logic
type MarketOrderStrategy struct{}

func (s *MarketOrderStrategy) Execute(ctx context.Context, service *orderService, orderCtx *dto.PlaceOrderContext) error <span class="cov0" title="0">{
        orderCtx.OrderDTO = serviceHelper.NewMarketOrderDtoByOrderReq(orderCtx)
        return service.executeOrderPlacement(ctx, orderCtx, true)
}</span>

func (s *orderService) getOrderPlacementStrategy(orderType model.OrderType) (OrderPlacementStrategy, error) <span class="cov0" title="0">{
        switch orderType </span>{
        case model.LIMIT:<span class="cov0" title="0">
                return &amp;LimitOrderStrategy{}, nil</span>
        case model.MARKET:<span class="cov0" title="0">
                return &amp;MarketOrderStrategy{}, nil</span>
        default:<span class="cov0" title="0">
                log.Errorf("[getOrderPlacementStrategy] failed, unknown order type: %v", orderType)
                return nil, ErrInvalidInput</span>
        }
}

// OrderPlacementStrategy &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

func (s *orderService) executeOrderPlacement(ctx context.Context, orderCtx *dto.PlaceOrderContext, isMarketOrder bool) error <span class="cov0" title="0">{
        // Phase 1: Process order placement
        if err := s.executeOrderPlacementPhase(ctx, orderCtx, isMarketOrder); err != nil </span><span class="cov0" title="0">{
                log.Errorf("[executeOrderPlacement] Phase-1 error: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">log.Debugf("[executeOrderPlacement] Phase-1 done: %v", orderCtx)

        // Phase 2: Process trade settlement
        if err := s.executeTradeSettlementPhase(ctx, orderCtx); err != nil </span><span class="cov0" title="0">{
                log.Errorf("[executeOrderPlacement] Phase-2 error: %v", err)
                return UnknownError
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *orderService) executeOrderPlacementPhase(ctx context.Context, orderCtx *dto.PlaceOrderContext, isMarketOrder bool) error <span class="cov0" title="0">{
        return WithTx(ctx, s.db, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // 1. Freeze user funds
                if err := s.balanceRepo.LockedByUserIdAndAsset(ctx, tx, orderCtx.UserID, orderCtx.Assets.FreezeAsset, orderCtx.Assets.FreezeAmt); err != nil </span><span class="cov0" title="0">{
                        log.Warnf("[executeOrderPlacementPhase] failed to lock user balance, %v", err)
                        return ErrInsufficientBalance
                }</span>

                // 2. Insert order to database
                <span class="cov0" title="0">if err := s.orderRepo.Insert(ctx, tx, orderCtx.OrderDTO); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("[executeOrderPlacementPhase] Insert Order error : %v", err)
                        return UnknownError
                }</span>

                // 3. Place order in matching engine
                <span class="cov0" title="0">engineOrder := serviceHelper.NewEngineOrderByOrderDto(orderCtx.OrderDTO)
                trades, err := s.engine.PlaceOrder(orderCtx.Market, orderCtx.Request.OrderType, engineOrder)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("[executeOrderPlacementPhase] Engine warning : %v", err)
                        return err
                }</span>

                // 4. Update order status from engine result
                <span class="cov0" title="0">orderCtx.SyncTradeResult(engineOrder, trades)

                // 5. Save trade records
                if len(orderCtx.Trades) &gt; 0 </span><span class="cov0" title="0">{
                        if err := s.tradeRepo.BatchInsert(ctx, tx, trades); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("[executeOrderPlacementPhase] BatchInsert Trades error : %v", err)
                                return UnknownError
                        }</span>
                }

                // 6. Handle market bid order special case
                <span class="cov0" title="0">if isMarketOrder &amp;&amp; orderCtx.Request.Side == model.BID </span><span class="cov0" title="0">{
                        if err := s.orderRepo.UpdateOriginalSize(ctx, tx, engineOrder.ID, engineOrder.OriginalSize); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("[executeOrderPlacementPhase] Handle market bid order special case error : %v", err)
                                return UnknownError
                        }</span>
                        <span class="cov0" title="0">orderCtx.OrderDTO.OriginalSize = engineOrder.OriginalSize</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s *orderService) executeTradeSettlementPhase(ctx context.Context, orderCtx *dto.PlaceOrderContext) error <span class="cov0" title="0">{
        if len(orderCtx.Trades) == 0 </span><span class="cov0" title="0">{
                return nil // No trades to settle
        }</span>

        <span class="cov0" title="0">settlementResult, err := serviceHelper.ProcessTradeSettlement(orderCtx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process trade settlement: %w", err)
        }</span>

        // Update orders
        <span class="cov0" title="0">for _, orderUpdate := range settlementResult.OrderUpdates </span><span class="cov0" title="0">{
                if err := s.orderRepo.SyncTradeMatchingResult(ctx, s.db, orderUpdate.OrderID, orderUpdate.RemainingSizeDecreasing, orderUpdate.DealtQuoteAmountIncreasing, orderUpdate.FeesIncreasing); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to sync trade matching result for order %s: %w", orderUpdate.OrderID, err)
                }</span>
        }

        // Update user balances
        <span class="cov0" title="0">for userID, settlement := range settlementResult.UserSettlements </span><span class="cov0" title="0">{
                if err := s.updateUserAssets(ctx, s.db, userID, orderCtx.Assets, settlement); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("updateUserAssets error: %v", err)
                        return err
                }</span>
        }

        // settle Fees Revenue to exchange's margin account
        <span class="cov0" title="0">if err := s.settleFeesRevenue(ctx, s.db, settlementResult); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateUserAssets Update user base and quote assets.html.
func (s *orderService) updateUserAssets(ctx context.Context, tx *sql.DB, userID string, assets *dto.AssetDetails, settlement *serviceHelper.UserSettlementData) error <span class="cov0" title="0">{
        // update BASE asset for user.
        if err := s.balanceRepo.UpdateAsset(ctx, tx, userID, assets.BaseAsset, settlement.BaseAssetAvailable, settlement.BaseAssetLocked); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update base asset: %w", err)
        }</span>
        // update Quote asset for user.
        <span class="cov0" title="0">if err := s.balanceRepo.UpdateAsset(ctx, tx, userID, assets.QuoteAsset, settlement.QuoteAssetAvailable, settlement.QuoteAssetLocked); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update quote asset: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *orderService) CancelOrder(ctx context.Context, userID, orderID string) (*dto.Order, error) <span class="cov0" title="0">{
        if userID == "" || orderID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidInput
        }</span>

        <span class="cov0" title="0">orderDto, err := s.orderRepo.GetOrderByOrderId(ctx, s.db, orderID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, ErrOrderNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get order: %w", err)</span>
        }

        <span class="cov0" title="0">if orderDto.UserID != userID </span><span class="cov0" title="0">{
                return nil, ErrOrderNotBelongsToUser
        }</span>

        <span class="cov0" title="0">engineOrder, err := s.engine.CancelOrder(orderDto.Market, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to cancel order in engine: %w", err)
        }</span>

        <span class="cov0" title="0">err = WithTx(ctx, s.db, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // Update order status
                orderDto.RemainingSize = engineOrder.RemainingSize
                orderDto.Status = model.ORDER_STATUS_CANCELED

                if err := s.orderRepo.Update(ctx, tx, orderDto); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update order: %w", err)
                }</span>

                // Calculate and process refund
                <span class="cov0" title="0">unlockAsset, unlockAmount, err := serviceHelper.CalculateRefund(s.engine, orderDto.Market, engineOrder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate refund: %w", err)
                }</span>

                <span class="cov0" title="0">if unlockAmount &gt; 0 </span><span class="cov0" title="0">{
                        if err := s.balanceRepo.UnlockedByUserIdAndAsset(ctx, tx, userID, unlockAsset, unlockAmount); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to unlock balance: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to cancel order transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return orderDto, nil</span>
}

func (s *orderService) QueryOrder(ctx context.Context, userID string, isOpenOrder bool) ([]*dto.Order, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidInput
        }</span>

        <span class="cov0" title="0">statuses := getOrderStatusesByOpenFlag(isOpenOrder)
        orders, err := s.orderRepo.GetOrdersByUserIdAndStatuses(ctx, s.db, userID, statuses)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (s *orderService) QueryOrderByMarket(ctx context.Context, userID string, market string, isOpenOrder bool) ([]*dto.Order, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidInput
        }</span>

        <span class="cov0" title="0">statuses := getOrderStatusesByOpenFlag(isOpenOrder)
        orders, err := s.orderRepo.GetOrdersByUserIdAndMarketAndStatuses(ctx, s.db, userID, market, statuses)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query orders: %w", err)
        }</span>

        <span class="cov0" title="0">return orders, nil</span>
}

func (s *orderService) QueryOrdersByMarketAndStatuses(ctx context.Context, market string, statuses []model.OrderStatus) ([]*dto.Order, error) <span class="cov0" title="0">{
        if market == "" || len(statuses) == 0 </span><span class="cov0" title="0">{
                return nil, ErrInvalidInput
        }</span>
        <span class="cov0" title="0">orders, err := s.orderRepo.GetOrdersByMarketAndStatuses(ctx, s.db, market, statuses)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return orders, nil</span>
}

func (s *orderService) PaginationQuery(ctx context.Context, query *dto.GetOrdersQueryReq) (*dto.PaginationResp[*dto.Order], error) <span class="cov0" title="0">{
        if query == nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidInput
        }</span>

        <span class="cov0" title="0">var endTime time.Time
        var statuses []model.OrderStatus

        switch query.Type </span>{
        case dto.OPENING_ORDER:<span class="cov0" title="0">
                statuses = []model.OrderStatus{model.ORDER_STATUS_NEW, model.ORDER_STATUS_PARTIAL}</span>
        case dto.CLOSED_ORDER:<span class="cov0" title="0">
                statuses = []model.OrderStatus{model.ORDER_STATUS_FILLED, model.ORDER_STATUS_CANCELED}
                // closed order only can search latest 3 months
                endTime = time.Now().AddDate(0, -3, 0)</span>
        default:<span class="cov0" title="0">
                return nil, ErrInvalidInput</span>
        }

        <span class="cov0" title="0">return s.orderRepo.PaginationQuery(ctx, s.db, query, statuses, endTime)</span>
}

func (s *orderService) settleFeesRevenue(ctx context.Context, tx *sql.DB, result *serviceHelper.TradeSettlementResult) error <span class="cov0" title="0">{

        err := s.balanceRepo.UpdateAsset(ctx, tx, settings.MARGIN_ACCOUNT_ID, result.BaseAsset, result.TotalBaseFees, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[PlaceOrder] settleFeesRevenue failed, error %v", err)
                return err
        }</span>
        <span class="cov0" title="0">err = s.balanceRepo.UpdateAsset(ctx, tx, settings.MARGIN_ACCOUNT_ID, result.QuoteAsset, result.TotalQuoteFees, 0)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[PlaceOrder] settleFeesRevenue failed, error %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getOrderStatusesByOpenFlag(isOpen bool) []model.OrderStatus <span class="cov0" title="0">{
        if isOpen </span><span class="cov0" title="0">{
                return []model.OrderStatus{
                        model.ORDER_STATUS_NEW,
                        model.ORDER_STATUS_PARTIAL,
                }
        }</span>
        <span class="cov0" title="0">return []model.OrderStatus{
                model.ORDER_STATUS_CANCELED,
                model.ORDER_STATUS_FILLED,
        }</span>
}

func validatePlacingOrderReq(user *dto.User, market string, req *dto.OrderReq) error <span class="cov0" title="0">{
        switch </span>{
        case user == nil:<span class="cov0" title="0">
                return errors.New("user is required")</span>
        case market == "":<span class="cov0" title="0">
                return errors.New("market is required")</span>
        case req == nil:<span class="cov0" title="0">
                return errors.New("order request is required")</span>
        }

        // Validate Ask orders
        <span class="cov0" title="0">if req.Side == model.ASK &amp;&amp; req.Size &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("ask order size must be greater than zero")
        }</span>

        // Validate Bid orders
        <span class="cov0" title="0">if req.Side == model.BID </span><span class="cov0" title="0">{
                if req.OrderType == model.MARKET &amp;&amp; req.QuoteAmount &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("bid market order quote amount must be greater than zero")
                }</span>
                <span class="cov0" title="0">if req.OrderType == model.LIMIT &amp;&amp; req.Size &lt;= 0 </span><span class="cov0" title="0">{
                        return errors.New("bid limit order size must be greater than zero")
                }</span>
        }

        // Validate Limit orders
        <span class="cov0" title="0">if req.OrderType == model.LIMIT &amp;&amp; req.Price &lt;= 0 </span><span class="cov0" title="0">{
                return errors.New("limit order price must be greater than zero")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package serviceImpl

import (
        "context"
        "database/sql"
)

func WithTx(ctx context.Context, db *sql.DB, fn func(tx *sql.Tx) error) (err error) <span class="cov0" title="0">{
        tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(p)</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span> else<span class="cov0" title="0"> {
                        err = tx.Commit()
                }</span>
        }()

        <span class="cov0" title="0">err = fn(tx)
        return</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package serviceImpl

import (
        "context"
        "crypto/rand"
        "database/sql"
        "errors"
        "fmt"
        "github.com/google/uuid"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/repository"
        "github.com/johnny1110/crypto-exchange/security"
        "github.com/johnny1110/crypto-exchange/service"
        "github.com/johnny1110/crypto-exchange/settings"
        "github.com/labstack/gommon/log"
        "golang.org/x/crypto/bcrypt"
        "time"
)

type userService struct {
        db              *sql.DB
        userRepo        repository.IUserRepository
        balanceRepo     repository.IBalanceRepository
        credentialCache *security.CredentialCache
}

func NewIUserService(db *sql.DB, userRepo repository.IUserRepository, balanceRepo repository.IBalanceRepository, credentialCache *security.CredentialCache) service.IUserService <span class="cov0" title="0">{
        return &amp;userService{
                db:              db,
                userRepo:        userRepo,
                balanceRepo:     balanceRepo,
                credentialCache: credentialCache,
        }
}</span>

func (s userService) GetUser(ctx context.Context, userId string) (*dto.User, error) <span class="cov0" title="0">{
        return s.userRepo.GetUserById(ctx, s.db, userId)
}</span>

func (s userService) Register(ctx context.Context, req *dto.RegisterReq) (string, error) <span class="cov0" title="0">{
        // gen userId
        userID, err := genUIDSecure()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("[Register] failed to generate user id: %v", err)
                return "", fmt.Errorf("failed to create user")
        }</span>
        // gen hash pwd
        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = WithTx(ctx, s.db, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                user, err := s.userRepo.GetUserByUsername(ctx, tx, req.Username)

                log.Infof("query username:[%s], got user: [%v], err:[%v]", req.Username, user, err)

                if err == nil </span><span class="cov0" title="0">{
                        log.Warn("[Register] user with username already exists")
                        return errors.New("username already exists")
                }</span>

                <span class="cov0" title="0">err = s.userRepo.Insert(ctx, tx, &amp;dto.User{
                        ID:           userID,
                        Username:     req.Username,
                        PasswordHash: string(hash),
                        VipLevel:     1,
                        MakerFee:     0.001,
                        TakerFee:     0.002,
                })

                err = s.balanceRepo.BatchCreate(ctx, tx, userID, settings.GetAllAssets())

                return err</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return userID, err</span>
}

func (s userService) Login(ctx context.Context, req *dto.LoginReq) (string, error) <span class="cov0" title="0">{
        user, err := s.userRepo.GetUserByUsername(ctx, s.db, req.Username)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("username not exists")
        }</span>
        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov0" title="0">{
                return "", errors.New("invalid credentials")
        }</span>

        <span class="cov0" title="0">token := uuid.NewString()
        s.credentialCache.Put(token, user)
        return token, nil</span>
}

func (s userService) Logout(ctx context.Context, token string) error <span class="cov0" title="0">{
        s.credentialCache.Delete(token)
        return nil
}</span>

func genUIDSecure() (string, error) <span class="cov0" title="0">{

        now := time.Now()
        dateStr := now.Format("060102")

        // gen 4 letters
        letters := "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        randomLetters := make([]byte, 4)
        letterBytes := make([]byte, 4)

        if _, err := rand.Read(letterBytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                randomLetters[i] = letters[letterBytes[i]%26]
        }</span>

        // gen 4 nums
        <span class="cov0" title="0">numberBytes := make([]byte, 2)
        if _, err := rand.Read(numberBytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">randomNumbers := (int(numberBytes[0])&lt;&lt;8+int(numberBytes[1]))%9999 + 1
        numberStr := fmt.Sprintf("%04d", randomNumbers)

        return fmt.Sprintf("UID%s%s%s", dateStr, string(randomLetters), numberStr), nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package serviceHelper

import (
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/engine-v2/core"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
)

// ParseMarket extracts base and quote assets.html from market
func ParseMarket(engine *core.MatchingEngine, market string) (string, string, error) <span class="cov0" title="0">{
        if engine == nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("engine cannot be nil")
        }</span>
        <span class="cov0" title="0">if market == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("market cannot be empty")
        }</span>

        <span class="cov0" title="0">orderBook, err := engine.GetOrderBook(market)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to get order book for market %s: %w", market, err)
        }</span>

        <span class="cov0" title="0">marketInfo := orderBook.MarketInfo()
        if marketInfo.BaseAsset == "" || marketInfo.QuoteAsset == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("invalid market info for market %s", market)
        }</span>

        <span class="cov0" title="0">return marketInfo.BaseAsset, marketInfo.QuoteAsset, nil</span>
}

// DetermineFreezeValue calculates which asset and amount to freeze
func DetermineFreezeValue(req *dto.OrderReq, baseAsset, quoteAsset string) (string, float64) <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return "", 0
        }</span>

        <span class="cov0" title="0">switch req.Side </span>{
        case model.BID:<span class="cov0" title="0">
                return calculateBidFreezeValue(req, quoteAsset)</span>
        case model.ASK:<span class="cov0" title="0">
                return baseAsset, req.Size</span>
        default:<span class="cov0" title="0">
                return "", 0</span>
        }
}

func calculateBidFreezeValue(req *dto.OrderReq, quoteAsset string) (string, float64) <span class="cov0" title="0">{
        switch req.OrderType </span>{
        case model.LIMIT:<span class="cov0" title="0">
                return quoteAsset, req.Price * req.Size</span>
        case model.MARKET:<span class="cov0" title="0">
                return quoteAsset, req.QuoteAmount</span>
        default:<span class="cov0" title="0">
                return quoteAsset, 0</span>
        }
}

func NewLimitOrderDtoByOrderCtx(orderCtx *dto.PlaceOrderContext) *dto.Order <span class="cov0" title="0">{
        return dto.NewOrderBuilder().
                WithMarket(orderCtx.Market).
                WithUser(orderCtx.UserID).
                WithSide(orderCtx.Request.Side).
                WithType(model.LIMIT).
                WithMode(orderCtx.Request.Mode).
                WithPrice(orderCtx.Request.Price).
                WithSize(orderCtx.Request.Size).
                WithFeeRate(orderCtx.FeeRate, orderCtx.FeeAsset).
                Build()
}</span>

func NewMarketOrderDtoByOrderReq(orderCtx *dto.PlaceOrderContext) *dto.Order <span class="cov0" title="0">{
        builder := dto.NewOrderBuilder().
                WithMarket(orderCtx.Market).
                WithUser(orderCtx.UserID).
                WithSide(orderCtx.Request.Side).
                WithType(model.MARKET).
                WithMode(model.TAKER).
                WithFeeRate(orderCtx.FeeRate, orderCtx.FeeAsset).
                WithPrice(-1) // Market orders don't have a specific price

        if orderCtx.Request.Side == model.BID </span><span class="cov0" title="0">{
                builder.WithQuoteAmount(orderCtx.Request.QuoteAmount)
        }</span> else<span class="cov0" title="0"> {
                builder.WithSize(orderCtx.Request.Size)
        }</span>

        <span class="cov0" title="0">return builder.Build()</span>
}

func NewEngineOrderByOrderDto(orderDto *dto.Order) *model.Order <span class="cov0" title="0">{
        if orderDto == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return model.NewOrder(
                orderDto.ID,
                orderDto.UserID,
                orderDto.Side,
                orderDto.Price,
                orderDto.RemainingSize,
                orderDto.QuoteAmount,
                orderDto.Mode,
                orderDto.FeeRate,
        )</span>
}

// CalculateRefund calculates refund amount for cancelled orders
func CalculateRefund(engine *core.MatchingEngine, market string, engineOrder *model.Order) (unlockAsset string, unlockAmount float64, err error) <span class="cov0" title="0">{
        if engine == nil || engineOrder == nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("engine and engineOrder cannot be nil")
        }</span>

        <span class="cov0" title="0">baseAsset, quoteAsset, err := ParseMarket(engine, market)
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("failed to parse market: %w", err)
        }</span>

        <span class="cov0" title="0">switch engineOrder.Side </span>{
        case model.BID:<span class="cov0" title="0">
                return quoteAsset, engineOrder.Price * engineOrder.RemainingSize, nil</span>
        case model.ASK:<span class="cov0" title="0">
                return baseAsset, engineOrder.RemainingSize, nil</span>
        default:<span class="cov0" title="0">
                return "", 0, fmt.Errorf("unknown order side: %v", engineOrder.Side)</span>
        }
}

func WrapPlaceOrderResult(orderDto *dto.Order, trades []book.Trade) *dto.PlaceOrderResult <span class="cov0" title="0">{
        if orderDto == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">matches := make([]*dto.Match, 0, len(trades))
        for _, trade := range trades </span><span class="cov0" title="0">{
                matches = append(matches, &amp;dto.Match{
                        Price:     trade.Price,
                        Size:      trade.Size,
                        Timestamp: trade.Timestamp,
                })
        }</span>

        <span class="cov0" title="0">return &amp;dto.PlaceOrderResult{
                Order:   *orderDto,
                Matches: matches,
        }</span>
}

func DetermineFeeInfo(req *dto.OrderReq, user *dto.User, baseAsset string, quoteAsset string) (feeAsset string, feeRate float64) <span class="cov0" title="0">{
        switch req.Mode </span>{
        case model.MAKER:<span class="cov0" title="0">
                feeRate = user.MakerFee
                break</span>
        case model.TAKER:<span class="cov0" title="0">
                feeRate = user.TakerFee
                break</span>
        default:<span class="cov0" title="0">
                panic("Unknown order mode")</span>
        }

        <span class="cov0" title="0">switch req.Side </span>{
        case model.BID:<span class="cov0" title="0">
                feeAsset = baseAsset
                break</span>
        case model.ASK:<span class="cov0" title="0">
                feeAsset = quoteAsset
                break</span>
        default:<span class="cov0" title="0">
                panic("Unknown order side")</span>
        }
        <span class="cov0" title="0">return feeAsset, feeRate</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package serviceHelper

import (
        "fmt"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/book"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
)

// OrderUpdateData represents data needed to update a dealt order
type OrderUpdateData struct {
        OrderID                    string
        RemainingSizeDecreasing    float64
        DealtQuoteAmountIncreasing float64
        FeesIncreasing             float64
}

// UserSettlementData represents settlement data for a user's assets.html
type UserSettlementData struct {
        BaseAssetAvailable  float64
        BaseAssetLocked     float64
        QuoteAssetAvailable float64
        QuoteAssetLocked    float64
}

// TradeSettlementResult encapsulates the result of trade settlement processing
type TradeSettlementResult struct {
        BaseAsset       string
        QuoteAsset      string
        OrderUpdates    []*OrderUpdateData
        UserSettlements map[string]*UserSettlementData
        TotalDealtAmt   float64
        TotalDealtSize  float64
        TotalBaseFees   float64 // add to settings margin account balances
        TotalQuoteFees  float64 // add to settings margin account balances
}

// ProcessTradeSettlement handles the core logic for processing trades and updating balances
func ProcessTradeSettlement(ctx *dto.PlaceOrderContext) (*TradeSettlementResult, error) <span class="cov0" title="0">{
        eatenOrder := ctx.OrderDTO
        trades := ctx.Trades

        if eatenOrder == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("eaten order cannot be nil")
        }</span>

        <span class="cov0" title="0">result := &amp;TradeSettlementResult{
                OrderUpdates:    make([]*OrderUpdateData, 0, len(trades)+1),
                UserSettlements: initializeUserSettlements(trades),
                BaseAsset:       ctx.Assets.BaseAsset,
                QuoteAsset:      ctx.Assets.QuoteAsset,
        }

        // Process each trade
        for _, trade := range trades </span><span class="cov0" title="0">{
                result.processIndividualTrade(trade, eatenOrder)
        }</span>

        // Add the eaten order to updates
        <span class="cov0" title="0">result.addEatenOrderUpdate(eatenOrder)

        // Update eaten order statistics
        if result.TotalDealtSize &gt; 0 </span><span class="cov0" title="0">{
                eatenOrder.AvgDealtPrice = result.TotalDealtAmt / result.TotalDealtSize
                eatenOrder.QuoteAmount = result.TotalDealtAmt
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// initializeUserSettlements creates settlement data for all users involved in trades
func initializeUserSettlements(trades []book.Trade) map[string]*UserSettlementData <span class="cov0" title="0">{
        userIds := extractUniqueUserIds(trades)
        settlements := make(map[string]*UserSettlementData, len(userIds))

        for uid := range userIds </span><span class="cov0" title="0">{
                settlements[uid] = &amp;UserSettlementData{}
        }</span>

        <span class="cov0" title="0">return settlements</span>
}

// extractUniqueUserIds gets all unique user IDs from trades
func extractUniqueUserIds(trades []book.Trade) map[string]bool <span class="cov0" title="0">{
        userIds := make(map[string]bool, len(trades)*2) // Preallocate for efficiency

        for _, trade := range trades </span><span class="cov0" title="0">{
                userIds[trade.BidUserID] = true
                userIds[trade.AskUserID] = true
        }</span>

        <span class="cov0" title="0">return userIds</span>
}

// processIndividualTrade handles the settlement logic for a single trade
func (r *TradeSettlementResult) processIndividualTrade(trade book.Trade, eatenOrder *dto.Order) <span class="cov0" title="0">{
        tradeQuoteAmount := trade.Price * trade.Size
        r.TotalDealtAmt += tradeQuoteAmount
        r.TotalDealtSize += trade.Size

        bidSettlement := r.UserSettlements[trade.BidUserID]
        askSettlement := r.UserSettlements[trade.AskUserID]

        // Process bid user balances
        bidFees := r.processBidUserBalances(bidSettlement, trade, tradeQuoteAmount, eatenOrder)

        // Process ask user balances
        askFees := r.processAskUserBalances(askSettlement, trade, tradeQuoteAmount)

        // Add opposite order update
        r.addOppositeOrderUpdate(trade, eatenOrder, tradeQuoteAmount, bidFees, askFees)
}</span>

// processBidUserBalances handles bid user's balance updates and return bid fees (Base Asset)
func (r *TradeSettlementResult) processBidUserBalances(bidSettlement *UserSettlementData, trade book.Trade, tradeQuoteAmount float64, eatenOrder *dto.Order) (fees float64) <span class="cov0" title="0">{
        // Handle quote asset (what bid user pays)
        if eatenOrder.Type == model.LIMIT &amp;&amp; eatenOrder.Side == model.BID </span><span class="cov0" title="0">{
                // If processing bid is incoming eatenOrder.
                // For limit buy orders, unlock at order price and refund difference
                unlockAmount := eatenOrder.Price * trade.Size
                bidSettlement.QuoteAssetLocked -= unlockAmount
                bidSettlement.QuoteAssetAvailable += unlockAmount - tradeQuoteAmount // Refund overpayment
        }</span> else<span class="cov0" title="0"> {
                // For other orders, unlock exact trade amount
                bidSettlement.QuoteAssetLocked -= tradeQuoteAmount
        }</span>

        // Calculate fees and accumulate to sum.
        <span class="cov0" title="0">bidFees := trade.Size * trade.BidFeeRate
        r.TotalBaseFees += bidFees

        // Add base asset received (deduct fees)
        bidSettlement.BaseAssetAvailable += trade.Size - bidFees

        return bidFees</span>
}

// processAskUserBalances handles ask user's balance updates and return ask fees (Quote Asset)
func (r *TradeSettlementResult) processAskUserBalances(settlement *UserSettlementData, trade book.Trade, tradeQuoteAmount float64) (fees float64) <span class="cov0" title="0">{
        // Remove locked base asset (what ask user sells)
        settlement.BaseAssetLocked -= trade.Size

        // Calculate fees and accumulate to sum.
        askFees := tradeQuoteAmount * trade.AskFeeRate
        r.TotalQuoteFees += askFees

        // Add quote asset received
        settlement.QuoteAssetAvailable += tradeQuoteAmount - askFees

        return askFees
}</span>

// addOppositeOrderUpdate adds update data for the order opposite to the eaten order
func (r *TradeSettlementResult) addOppositeOrderUpdate(trade book.Trade, eatenOrder *dto.Order, tradeQuoteAmount, bidFees, askFees float64) <span class="cov0" title="0">{
        var oppositeOrderId string
        var feeIncreasing float64
        if eatenOrder.Side == model.BID </span><span class="cov0" title="0">{
                oppositeOrderId = trade.AskOrderID
                feeIncreasing = askFees
        }</span> else<span class="cov0" title="0"> {
                oppositeOrderId = trade.BidOrderID
                feeIncreasing = bidFees
        }</span>

        <span class="cov0" title="0">r.OrderUpdates = append(r.OrderUpdates, &amp;OrderUpdateData{
                OrderID:                    oppositeOrderId,
                RemainingSizeDecreasing:    trade.Size,
                DealtQuoteAmountIncreasing: tradeQuoteAmount,
                FeesIncreasing:             feeIncreasing,
        })</span>
}

// addEatenOrderUpdate adds the eaten order to the updates list
func (r *TradeSettlementResult) addEatenOrderUpdate(eatenOrder *dto.Order) <span class="cov0" title="0">{
        var update *OrderUpdateData

        if eatenOrder.Type == model.MARKET &amp;&amp; eatenOrder.Side == model.BID </span><span class="cov0" title="0">{
                // Market bid orders don't need size/amount updates as they're already processed
                update = &amp;OrderUpdateData{
                        OrderID:                    eatenOrder.ID,
                        RemainingSizeDecreasing:    0.0,
                        DealtQuoteAmountIncreasing: 0.0,
                        FeesIncreasing:             r.TotalBaseFees,
                }
        }</span> else<span class="cov0" title="0"> {
                // Limit orders and market sell orders need full updates
                var fees float64
                if eatenOrder.Side == model.BID </span><span class="cov0" title="0">{
                        fees = r.TotalBaseFees
                }</span> else<span class="cov0" title="0"> {
                        fees = r.TotalQuoteFees
                }</span>

                <span class="cov0" title="0">update = &amp;OrderUpdateData{
                        OrderID:                    eatenOrder.ID,
                        RemainingSizeDecreasing:    r.TotalDealtSize,
                        DealtQuoteAmountIncreasing: r.TotalDealtAmt,
                        FeesIncreasing:             fees,
                }</span>
        }
        <span class="cov0" title="0">eatenOrder.Fees += update.FeesIncreasing

        r.OrderUpdates = append(r.OrderUpdates, update)</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package settings

import "fmt"

type CacheKeyPrefix string

func (c CacheKeyPrefix) Apply(key string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s", string(c), key)
}</span>

func (c CacheKeyPrefix) ApplyWithSuffix(key, suffix string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s:%s", string(c), key, suffix)
}</span>

const MARKET_DATA_CACHE = CacheKeyPrefix("MDC")
</pre>
		
		<pre class="file" id="file50" style="display: none">package settings

import "github.com/johnny1110/crypto-exchange/engine-v2/market"

func GetAllAssets() []string <span class="cov0" title="0">{
        return []string{"USDT", "BTC", "ETH", "DOT", "ASTR", "HDX"}
}</span>

var ALL_MARKETS = []*market.MarketInfo{
        {Name: "BTC-USDT", BaseAsset: "BTC", QuoteAsset: "USDT"},
        {Name: "ETH-USDT", BaseAsset: "ETH", QuoteAsset: "USDT"},
        {Name: "DOT-USDT", BaseAsset: "DOT", QuoteAsset: "USDT"},
}

const MARGIN_ACCOUNT_ID = "0"
const INTERNAL_AMM_ACCOUNT_ID = "MID250606CXAZ1199"
</pre>
		
		<pre class="file" id="file51" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "github.com/ethereum/go-ethereum/ethclient"
        "github.com/johnny1110/crypto-exchange/container"
        "github.com/johnny1110/crypto-exchange/dto"
        "github.com/johnny1110/crypto-exchange/engine-v2/model"
        "github.com/labstack/gommon/log"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "time"
)

func initLogger(logDir string, level log.Lvl) error <span class="cov0" title="0">{
        err := os.MkdirAll(logDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">today := time.Now().Format("2006-01-02")
        logFile, _ := os.OpenFile(
                fmt.Sprintf("%s/app_%s.log", logDir, today),
                os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)

        multiWriter := io.MultiWriter(os.Stdout, logFile)
        log.SetOutput(multiWriter)

        log.SetLevel(level)
        return nil</span>
}

func runSQLFilesWithTransaction(db *sql.DB) error <span class="cov0" title="0">{
        sqlFiles := []string{
                "./doc/db_schema/schema.sql",
                "./doc/db_schema/testing_data.sql",
        }

        for _, filePath := range sqlFiles </span><span class="cov0" title="0">{
                if err := executeSQLFileWithTransaction(db, filePath); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute %s: %w", filePath, err)
                }</span>
                <span class="cov0" title="0">log.Infof("Successfully executed: %s", filePath)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func executeSQLFileWithTransaction(db *sql.DB, filePath string) error <span class="cov0" title="0">{
        // Check if file exists
        if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("SQL file does not exist: %s", filePath)
        }</span>

        // Read the SQL file
        <span class="cov0" title="0">content, err := ioutil.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read SQL file %s: %w", filePath, err)
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback() // Will be ignored if tx.Commit() succeeds

        // Split the content by semicolons to handle multiple statements
        statements := strings.Split(string(content), ";")

        // Execute each statement within the transaction
        for i, statement := range statements </span><span class="cov0" title="0">{
                statement = strings.TrimSpace(statement)
                if statement == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if _, err := tx.Exec(statement); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute statement %d in %s: %w\nStatement: %s",
                                i+1, filepath.Base(filePath), err, statement)
                }</span>
        }

        // Commit the transaction
        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func recoverOrderBook(c *container.Container) error <span class="cov0" title="0">{
        log.Infof("[RecoverOrderBook] start")
        markets := c.MatchingEngine.Markets()

        ctx := context.Background()

        for _, marketName := range markets </span><span class="cov0" title="0">{
                log.Infof("[RecoverOrderBook] trying to recover market: %s", marketName)
                openOrderStatuses := []model.OrderStatus{model.ORDER_STATUS_NEW, model.ORDER_STATUS_PARTIAL}
                orderDTOs, err := c.OrderService.QueryOrdersByMarketAndStatuses(ctx, marketName, openOrderStatuses)
                if len(orderDTOs) == 0 </span><span class="cov0" title="0">{
                        log.Infof("[RecoverOrderBook] no order found in market: %s", marketName)
                        continue</span>
                }
                <span class="cov0" title="0">latestPrice, err := c.TradeRepo.GetMarketLatestPrice(ctx, c.DB, marketName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("[RecoverOrderBook] failed to get latest price for market: %s, using default 0.0", marketName)
                        latestPrice = 0.0
                }</span>

                <span class="cov0" title="0">orders := convertOrderDTOsToEngineOrders(orderDTOs)
                err = c.MatchingEngine.RecoverOrderBook(marketName, orders, latestPrice)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func convertOrderDTOsToEngineOrders(orderDTOs []*dto.Order) []*model.Order <span class="cov0" title="0">{
        orders := make([]*model.Order, 0, len(orderDTOs))
        for _, o := range orderDTOs </span><span class="cov0" title="0">{
                orders = append(orders, o.ToEngineOrder())
        }</span>
        <span class="cov0" title="0">return orders</span>
}

func startUpAllScheduler(c *container.Container) <span class="cov0" title="0">{
        err := c.OrderBookSnapshotScheduler.Start()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">err = c.MarketDataScheduler.Start()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        //TODO: bugged, no cancel order
        <span class="cov0" title="0">err = c.LQDTScheduler.Start()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func getEthClient() (*ethclient.Client, error) <span class="cov0" title="0">{
        return ethclient.Dial("http://localhost:8545")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
